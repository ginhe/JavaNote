# 数据库

## mybatis中的#和$的区别

Mybatis 的Mapper.xml语句中parameterType向SQL语句传参有两种方式：#{}和${}。

（1）对于#传进来的参数，mybatis默认当成字符串。而对于$传进来的参数，mybatis不会进行特殊处理。

举例说明：我们传入的参数是表名test：

- `selec * from #{table};`会被解析`select * from "test"; `
- `select * from ${table};`会解析成`select * from test;`

前者由于多了引号会失败，后者可以成功查询。

> MyBatis排序时使用order by 动态参数的是$而不是#
>
> $方式一般用于传入数据库对象，例如传入表名.

（2）\#和$在预编译处理中不一样。\#类似jdbc中的PreparedStatement，对于传入的参数，在预处理阶段会使用?代替，比如：

```sql
select * from student where id = ?;
```

直到真正查询时踩在数据库管理系统中带入参数。

而$是简单替换：

```
select * from student where id = 2;
```

前者的这个性质可以防止sql注入，而后者可能导致sql注入成功。

>**SQL注入**
>
>程序员在编写的代码中没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。使得可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据。
>
>比如说查询用户：`select * from user where name=' "+name+" ' and password=' "+password+" '`这样的sql语句
>
>那么如果用户输入用户名admin和密码123456' or  'abc' = 'abc'，那么拼接出来的语句就是：
>
>select * from user where name=' admin ' and password='123456' or 'abc'= 'abc';
>
>这样只要user表有数据，就会返回结果



## varchar和char区别

 char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足。（在检索操作中那些填补出来的空格字符将被去掉）

在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）．



# 基础知识

## 哈希冲突的解决

（1）开放定址法

从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。

> ThreadLocal的set方法中的rehash使用到了该方法

（2）链表法

将哈希值相同的元素构成一个单链表，并将单链表的头指针存放在哈希表的第i个单元中。

> HashMap采用该解决方案：Jdk1.7完全采用单链表来存储，JDK1.8采用混合模式：链表和红黑树。



## 什么是跳板机

跳板机是可以给你远程连接的机器，然后通过这个机器再去访问别的机器，这个跳板机可以是`windows`下也可以是`Linux`下

举例说明：很多客户方的服务器外网是连接不了的，一般只能通过`VPN`然后才能连接，然而一些客户方觉得做`VPN`的代价太大，但是开发方不方便经常去现场或者其他原因需要访问客户方的服务器并且服务器外网不能连接时，没有`VPN`时，只能通过远程连接，比如`teamview`,`QQ`远程，还有`windows`自带的远程连接工具，连接到远端的一台电脑上，这台电脑就是跳板机，作为一个桥梁，然后再通过这个机器在内网中访问其服务器



# 场景题

## 统计在线用户数

每当有新的用户访问店铺时，服务端生成唯一的sessionId，将店铺id和sessionId放在redis的set里。因此统计在线用户数就是查看set的长度。

**如何知道用户离开店铺？**（关闭浏览器或者用户关闭店铺的所有页面并且在一定时间内未调用心跳通知接口）

可以设置key的失效事件，使用代码监听redis这个key失效的事件。
如果是新用户（第一次访问）调用，我会将其sessionid作为key保存到redis里面，并且设置它的失效事件（暂且设为1min），如果不是新用户，直接更新这个key即可；更新接口做一样操作，直接更新这个key，这样，只要有心跳通知，或者收集接口，这个key会一直存在，也就认为这个用户在线；如果超过一分钟未更新，那么key的失效事件会被触发，同时将sessionid从xxx_shopId的set集合中移除即可。



## 当一个页面反应特别慢时可能是什么原因

以服务器的角度来看：

（1）服务器出口带宽不够用：可能是购买的服务器出口带宽就很小，旦用户访问量上来了，并发量大了，自然均分给用户的出口带宽就更小了，所以某些用户的访问速度就会下降了很多。此外跨运营商网络导致带宽缩减，例如很多服务器是放在电信的网络上的，而如果用户这边对接的是长城或者说联通的宽带，运营商之间网络传输在对接时是会有限制的，这就可能导致带宽的缩减。

（2）服务器负载过大，比如CPU和内存消耗完了。

（3）网站的开发代码没写好，例如mysql语句没有进行优化，导致数据库的读写相当耗费时间。

（4）数据库的瓶颈：当我们的数据库变得愈发庞大，那对于数据库的读写就会变得相当缓慢了，索引优化固然能提升一些效率，但数据库已经如此庞大的话，如果每次查询都对这么大的数据库进行全局查询，自然会很慢。



## DDOS攻击

**DOS攻击**

中文名称是拒绝服务，攻击原理是：攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认（TCP的三次握手），由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处于等待状态，而分配给这次请求的资源却没有被释放。当服务器等待一定的时间后 超时断开，这时攻击者再次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪。

### SYN攻击

在TCP三次握手的第二次握手中，服务器会把第一次握手发来的请求加入未连接队列，然后发送确认报文给客户。如果没有收到第三次握手的确认包，则会重发确认报，直到超时或半连接数量超过半连接队列的最大值，将此条目从未连接队列删除。

SYN攻击属于DoS攻击的一种，它大量发送伪造的第一次握手数据包，这样服务器每接收到一个SYN包就会为这个连接信息分配核心内存并放入半连接队列，如果短时间内接收到的SYN太多，半连接队列就会溢出，操作系统会把这个连接信息丢弃造成不能连接。当攻击的SYN包超过半连接队列的最大值时，正常的客户发送SYN数据包请求连接就会被服务器丢弃。目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。



**DDOS攻击**

中文名是分布式拒绝服务。它是在DOS基础上进行的大规模，大范围的攻击模式。DOS只是单机和单机之间的攻击模式，而*DDOS*是利用一批受控制的僵尸主机向一台服务器主机发起的攻击，其攻击的强度和造成的威胁要比*DOS*严重很多，更具破坏性。

攻击原理是：攻击者寻找僵尸主机，在互联网上寻找一些有后门漏洞的主机，然后入侵系统安装控制程序，入侵的越多，控制的僵尸主机就越多，攻击源就更多，然后分配入侵的主机 ，一部分充当攻击的主要控制端，一部分充当攻击源，在攻击者统一指挥下 对被攻击的服务器发起攻击，由于这个攻击模式是在幕后操作，所以很难被监控系统跟踪， 身份不容易被发现。





# 参考资料

[统计当前在线用户数](https://my.oschina.net/beanGo/blog/1507424)

[mybatis中的#和$的区别](https://blog.csdn.net/zymx14/article/details/78067452)

[网站打开很慢是什么原因](https://blog.csdn.net/lv_victor/article/details/53148421)

[varchar和char的区别](https://www.cnblogs.com/jewave/p/6214540.html)

[什么是跳板机](https://segmentfault.com/q/1010000010948194)