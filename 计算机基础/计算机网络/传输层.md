# 概述

传输层协议为 运行在不同主机上的应用进程之间提供**逻辑通信**功能，这些主机也许位于地球的两侧，通过很多路由器及多种不同类型的链路相连。

- 在发送端，传输层将 从发送应用进程接收到的报文划分成较小的块，并为每块加上一个传输层首部。然后传输层将这些报文段传递给网络层。

- 在接收端，网络层从数据报中提取传输层报文段，并将其上交给传输层。传输层处理该报文段，使得该报文段中的数据为接收应用进程使用。




## 多路复用和分用

假如我们正在计算机中下载Web页面，同时还运行一个FTP会话和两个Telnet会话，即此时我们有4个网络应用进程在运行：两个Telnet进程，一个FTP进程和一个HTTP进程。在目的主机的角度上，传输层从网络层接收数据后，需要将数据定向到这4个进程中的一个，或者应该说是：将数据交给中间的套接字。

> 一个进程有一个或多个套接字。

**多路分用**

当主机接收到IP数据报后，每个数据报携带源IP地址，目的IP地址。每个数据报携带一个报文段，每个段携带源端口号和目的端口号。

接收端的传输层会提取出IP地址和端口号信息，将报文段导向到该套接字。

**多路复用**

从源主机的不同套接字中收集数据块，每个数据块封装上首部信息，从而生成报文段（报文段里有指示要交付到的套接字，即源端口号字段和目的端口号字段），然后将报文段传递给网络层。

![img](https://img-blog.csdnimg.cn/20200414131251374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)

> 端口总共有65535个，这是因为TCP，UDP是用16位存储源端口号和目标端口号，即$2^{16}$。



# UDP

## 概述

UDP只是做了传输协议所能做的最少工作，除了复用/分用功能和少量的差错检测外，它几乎没有对IP协议增加别的东西。

UDP从应用进程得到数据后，附加上用于多路复用/分用服务的源和目的端口号字段，以及两个其他小字段，然后将此形成的报文段交给网络层。而网络层将报文段封装到一个IP数据报中，然后**尽力**尝试将报文段交付给正确的应用进程。

> （1）传输层提供端到端的逻辑通信服务，在这个过程中，他可能经过多个路由器，可能使用不同的物理媒介，不同的链路层协议。我们不能保证所有的链路层协议都有错误检验和恢复机制；即便链路层协议都有这些机制，那么在路由器中，存储，转发的过程中也可能出错。
>
> （2）DNS是一个使用UDP的的应用层协议例子，当一台主机中的DNS应用程序想要进行1次查询时，它构造了DNS查询报文并交给UDP，主机端的UDP为此报文去添加首部字段，然后交给网络层，网络层将UDP报文段封装进一个IP数据报中，然后发送给一个名字服务器。查询主机的DNS应用程序等待查询回应，若没有收到，要么试图向另一个名字服务器发送查询，要么通知调用的应用程序它不能获取响应。

**特点**

（1）它提供的是”尽力而为“服务，不保证可靠交付；

（2）非按序到达。

（3）它是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。；

（4） 每个UDP报文段的处理独立于其他报文段。

（5） UDP是面向报文的。发送方的UDP对应用层交下来的报文，既不合并也不拆分，在添加首部后就向下交付IP层。



**UDP的优点**

1. 无需建立连接，不会引入建连的时延。(这就是为什么DNS使用该协议）
2. 头部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。
3. 没有拥塞控制：应用可更好地控制发送时间和速率 



**如何在UDP上实现可靠数据传输**

模仿传输层TCP的可靠性传输（不考虑拥塞处理的情况）：

- 添加seq/ack机制，确保数据发送到对端
- 添加发送和接收缓冲区，主要是用户超时重传。
- 添加超时重传机制。



## UDP报文段格式

![img](https://img-blog.csdnimg.cn/20200414133625909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



它由如下字段组成：

- 16位源端口号和目的端口号
- 16位UDP长度
- UDP校验和（错误校验的功能）；
- 报文



# TCP

## 特点

2. 可靠的，按序的字节流
2. 面向连接。通信双方在发送数据前必须建立连接；连接状态只有两端维护，在沿途节点（比如中间的路由器）并不维护状态；
3. 接收方和发送方都有缓存
4. TCP拥塞控制和流量控制机制 设置窗口尺寸
5. 提供了全双工服务：同一连接中能传输双向数据流
6. TCP是面向字节流的：将应用层数据写入TCP缓存区中，由TCP协议控制发送缓存区里的数据，发送的状态是按字节流的方式发送。

**TCP和UDP的区别**

<img src="https://img-blog.csdnimg.cn/20200306150849796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />

**TCP和UDP的应用**

<img src="https://img-blog.csdnimg.cn/2020030918380257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



## 报文首部主要字段

![img](https://img-blog.csdnimg.cn/20200307090219786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**序号Seq**：

发送方的TCP会隐式的对数据流中的每一个字节编号。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。每一个序号被填入到相应TCP报文段首部的序号字段中。

**确认值ACK**：1表示确认进行连接

**数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

**确认编号ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

**同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1表示接受到信息。

**终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

**窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。





## 滑动窗口

TCP 每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这种传输方式存在一个缺点：数据包的往返时间越长，通信的效率就越低。

为了解决此问题，TCP引入窗口的概念：

![img](https://img-blog.csdnimg.cn/20200307102950314.png)

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

滑动窗口用来管理已发送出去但还未被确认的分组，若窗口大小为N，表示最多有N个等待确认的消息。如果按期收到确认应答，此分组就可以从缓存区清除。

**窗口大小由哪一方决定？**

TCP 头里有一个字段叫 `Window`，也就是窗口大小。接收端通过该字段告知发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。因此通常窗口的大小是由接收方的决定的。

**发送方的滑动窗口**

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a765447993054aff85a662b0a9acd8dd~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:80%;" />

**接收方的滑动窗口**

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e169ede8b4d54286bf983897e5731c9c~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:80%;" />



## 流量控制

**发送缓存和接收缓存**

发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源。

因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡。我们将对发送方发送速率的控制 称为流量控制。

**流量控制**

接收方每次收到数据包，可以在发送确定报文同时告诉发送方自己的接收窗口大小的。

 <img src="https://user-gold-cdn.xitu.io/2020/7/28/17393666247dd288?w=959&amp;h=718&amp;f=png&amp;s=184172" style="zoom: 50%;" />

发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。

**流量控制引发的死锁问题**

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。



## 拥塞控制

早期的TCP实现是没有拥塞窗口的，发送方根据接收窗口的大小 发送数据过去。如果传输路径没有问题，比如发送方，接收方都在一个局域网内，自然没问题。但如果传输路径有问题，比如宽带有限，承受不了这么多数据，那就需要TCP的确认重传机制。

因此TCP提出了拥塞控制，拥塞窗口是拥塞控制的一部分，它是发送方每次发送的数据长度。简单的说，发送方在收到接收方的建议数据长度后，由于发送方不知道传输路径负载能力如何，因此开始时只发一小段数据。在收到ACK后，增加每次发送的数据，直至达到接收方的处理能力上限或传输路径的负载能力上限。

> **拥塞控制与流量控制的区别**
>
> 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。
>
> 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况

TCP通过四个算法来进行拥塞控制：

- 慢开始；
- 拥塞避免；
- 快重传；
- 快恢复。

首先介绍几个窗口的概念：

- 拥塞窗口cwnd：发送方根据对当前网络拥塞程度的估计而确定的窗口值，即发送方每次发送的数据长度。发送窗口=min(拥塞窗口，接收窗口)
- 接受窗口rwnd：接收方根据自己接收缓存的大小，调整返回给发送方的TCP报文段首部中的窗口字段值。
- 慢开始门限ssthresh：为了防止cwnd增长过大引起网络拥塞而设置的变量。



下图是拥塞控制的四个算法经历的过程：



![img](https://img-blog.csdnimg.cn/20200415083410114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**（1）慢开始算法**

发送方维持拥塞窗口cwnd的值，它是动态变化的。每经过一个RTT时，拥塞窗口就会加倍，直到达到阈值ssthresh。通过增加拥塞窗口的大小，来探测网络的拥塞程度。这里的“慢”是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大。

![img](https://img-blog.csdnimg.cn/20200307152032253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**（2）拥塞避免**

当采用慢开始后达到阈值ssthresh后，改用拥塞避免算法：每经过一个RTT后，拥塞窗口自增1，按照线性规律增长。当出现一次超时（没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理）后，立刻将阈值ssthresh降为当前ssthresh的一半，然后把拥塞窗口重置为1，开始执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

**（3）快重传算法**

如果接收方收到失序的报文段（例如M1，M2，M4，则M4为失序报文），则立即回送一个ACK，这样就可以让发送方尽早知道M3未到达接收方。如下图所示，M1，M2成功接收，M3丢失，因此后面发送方发送M4，M5，M6后，都会收到接收方的M2确认分组。在收到多个重复确认后，就立即发送报文M3，而不是等到M3的重传计时器。

![img](https://img-blog.csdnimg.cn/20200307153208170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**（4）快恢复**

一旦出现超时重传，或者收到第三个重复的 ack 时（快重传），TCP 会设置慢启动门限 ssthresh = cwnd / 2，同时拥塞窗口cwnd = ssthresh 。并进入拥塞避免。





## TCP连接管理

### 三次握手

TCP的发送方和接收方在传输数据前需要建立连接 ，连接的发起者是客户端。TCP的连接采用了三次握手的机制。

- TCP服务器进程先创建传输控制块TCB的，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
- TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，报文首部中的SYN=1，同时选择一个初始序列号 seq=x ，此时TCP客户端进程进入了 **同步已发送状态**。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
- TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中确认值 ACK=1，同步SYN=1，确认编号ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入**同步收到状态**。这个报文也不能携带数据，但是同样要消耗一个序号。
- TCP客户进程收到确认后，还要向服务器给出确认。确认报文的确认值ACK=1，确认编号ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入**已建立连接状态**。此时报文段可以携带数据，但若不携带数据则不消耗序号。
- 当服务器收到客户端的确认后也进入**已建立连接状态**，此后双方就可以开始通信了。

<img src="https://img-blog.csdnimg.cn/20200307143141243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**（1）为什么要传回SYN；传递了SYN又为什还要传递ACK？**

双方通信无误必须是两者互相发送信息都无误。传了SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来进行验证。

**（2）为什么需要三次握手？**

三次握手的目的是建立可靠的通信信道。所谓通信，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果只有两次握手的情况：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个失效的报文会让服务器误以为又新建立连接而去等待客户端发送数据，而客户端却不会理睬这个失效的报文，

如果是三次握手的情况：就算是失效的报文传突然送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端已经下线而且不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接，因此无法建立连接。

**（3）三次握手的意义**

三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小信息。

**包丢失**

**（1）第一次握手的SYN包丢失了会怎样？**

当客户端没有收到服务端的ACK，就会在超时重传SYN 数据包。每次超时重传的 RTO 是翻倍上涨的，直到 SYN 包的重传次数到达 `tcp_syn_retries` 值后，客户端不再发送 SYN 包。

**（2）第二次握手的SYN、ACK 包丢失会怎样？**

客户端 SYN 包会发生超时重传，服务端 SYN、ACK 也会发生超时重传。两者超时重传的最大次数由两个值决定，默认都为5。

**（3）第三次的 ack包丢失会怎样？**

对于服务器而言：此时它的状态为同步收到状态。它会一直重传 SYN、ACK 包，直到重传次数超过 `tcp_synack_retries` 值（默认值 5 次）后，服务端就会断开 TCP 连接。

而客户端会有两者情况：

- 如果客户端没发送数据包，一直处于已建立连接状态。经过一段时间后发现这是一个「死亡」连接，于是客户端连接就会断开连接。
- 如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 `tcp_retries2` 值（默认值 15 次）后，客户端就会断开 TCP 连接。



### 四次握手

![img](https://img-blog.csdn.net/20160313184308941)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



- 客户端进程发出连接释放报文，并且停止发送数据。报文的终止FIN=1，序列号seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入**终止等待1状态**。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 服务器收到连接释放报文，发出确认报文，确认值ACK=1，确认编号ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了**关闭等待状态CLOSE_WAIT**。此时连接处于半关闭状态，即客户端已经没有数据要发送了，但如果服务器要发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个关闭等待状态持续的时间。
- 客户端收到服务器的确认请求后，此时，客户端就进入**终止等待2状态**，等待服务器发送连接释放报文。在这段等待时间内还需要接受服务器发送的最后的数据。
- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，终止FIN=1，确认编号ack=u+1，序列号seq=w。此时，服务器就进入了**最后确认状态**，等待客户端的确认。
- 客户端收到服务器的连接释放报文后，必须发出确认，确认值ACK=1，确认编号ack=w+1，序列号是seq=u+1，此时，客户端就进入了**时间等待状态TIME_WAIT**。注意此时TCP连接还没有释放，必须经过2 * MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。



> **TCP为什么是四次挥手？**
>
> 解释1：确保数据能够完成传输。当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。
>
> 解释2：任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
>
> **为什么客户端最后还要等待2MSL**
>
> 在第4次挥手后，客户端无法知道服务器是否收到ACK：如果没有收到，则服务器会超时重传第三次挥手的FIN；如果收到了，服务器不会有任何表示。因此客户端要等待一段时间，等待的这个时间就等于第四次挥手发送过去的ACK的最大存活时间MSL+服务器第三次挥手发过来的FIN（服务器没有收到第四次挥手的情况）的最大存活时间MSL，也就是2MSL。
>
> **如果已经建立了连接，但是客户端突然出现故障了怎么办？**
>
> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



#### 出现大量CLOSE_WAIT

CLOSE_WAIT是指在第二次挥手中，服务器收到FIN进入了CLOSE_WAIT状态。如果服务器不执行close()，就会一直处于CLOSE_WAIT状态。造成这种情况的原因有：

- 代码中没有写关闭连接的代码
- 该连接的业务代码处理时间太长，代码还在处理，对方已经发起断开连接请求; 也就是客户端因为某种原因在服务端还没有完成业务代码就发出了FIN信号，导致服务端被动关闭，若服务端不主动关闭socket发FIN给Client，此时服务端Socket会处于 `CLOSE_WAIT` 状态

由于某种原因导致的 `CLOSE_WAIT` ，会维持一段时间。如果服务端程序因某个原因导致系统造成一堆 `CLOSE_WAIT` 消耗资源，那么通常是等不到释放那一刻，系统就已崩溃。TOMCAT失去响应等等。

> 解决方法是查看代码

#### 出现大量TIME_WAIT

当首先主动关闭的是服务器时：如果业务处理+传输数据的时间远小于  TIMEWAIT超时的时间，则对于高并发短连接的TCP服务器来说，当服务器处理请求后立刻主动正常关闭连接，此时这个业务用过的端口会停留在TIMEWAIT状态，在停留的时间内，其他HTTP请求来临的时候是无法占用此端口的。因此如果关注一下服务器的利用率，你会发现服务器处理业务的时间和端口被挂着无法占用的时间比例是1:几百，也就是说服务器资源严重浪费。

解决思路是让服务器能够快速回收和重用那些TIME_WAIT的资源，比如说在`/etc/sysctl.conf`修改一些配置：

```
net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout修改系統默认的TIMEOUT时间
```





## TCP粘包/拆包问题

TCP是个“流”协议，没有消息保护边界，因此TCP会根据TCP缓冲区的实际情况进行包的划分，一个完整的报文可能会被TCP拆分成多个报文进行发送，也有可能把多个小的报文封装成一个大的报文发送，这就是所谓的TCP粘包和拆包问题。

如下图所示：

![img](https://img-blog.csdnimg.cn/20200307184435674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

客户端分别发送两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。

（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；

（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；

（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；

（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。



**原因：**

- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
- 待发送数据大于最大报文长度（MSS），TCP在传输前将进行拆包
- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包



**解决方案**：

- 将消息分为消息头，消息体。在消息头中声明消息的长度，根据长度来获取报文。
- 把每个数据报封装为固定长度，（不够的补0填充），
- 在数据包之间设置边界，比如添加特殊符号。这样接收端可以通过边界将不同数据包拆开。



## TCP 延迟确认与 Nagle 算法

当我们 TCP 报文的承载的数据非常小的时候，例如几个字节，那么整个网络的效率是很低的，因为每个 TCP 报文中都有会 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，而数据只有几个字节，所以在整个报文中有效数据占有的比重就会非常低。

因此便有了常见的两种策略，来减少小报文的传输，分别是：

- Nagle 算法
- 延迟确认

### Nagle 算法

该算法的策略是：

- 当没有已发送未确认报文时，立刻发送数据。
- 存在未确认报文时，直到「没有已发送未确认报文」或「数据长度达到 MSS 大小」时，再发送数据。

只要没有满足上面条件中的一条，发送方就一直囤积数据，直到满足上面所有条件。

![](https://user-gold-cdn.xitu.io/2020/7/8/1732c419acc162c5?w=698&h=530&f=png&s=128677)

上述是启用了Nagle算法的过程：

1. 由于没有已发送未确认的报文，所以先发了 H 字符；
2. 在还没收到对 H 字符的确认报文时，发送方就一直在囤积数据，直到收到了确认报文后，此时就没有已发送未确认的报文，于是就把囤积后的 ELL 字符一起发给了接收方；
3. 待收到对 ELL 字符的确认报文后，于是把最后一个 O 字符发送出去

### 延迟确认

对于没有携带数据的ACK，它的网络效率是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但没有携带数据。

为了解决 ACK 传输效率低问题，所以就衍生出了 **TCP 延迟确认**。

TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

![](https://user-gold-cdn.xitu.io/2020/7/8/1732c5f6e24b15d0?w=560&h=575&f=png&s=199825)

当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增长，如下图：

![](https://user-gold-cdn.xitu.io/2020/7/8/1732c60254a23f7c?w=418&h=526&f=png&s=79373)

上图的过程如下：

- 发送方先发出一个小报文，接收方收到后，由于延迟确认机制，自己又没有要发送的数据，只能干等着发送方的下一个报文到达；
- 而发送方由于 Nagle 算法机制，在未收到第一个报文的确认前，是不会发送后续的数据；
- 所以接收方只能等待最大时间 200 ms 后，才回 ACK 报文，发送方收到第一个报文的确认报文后，也才可以发送后续的数据。

解决的方法只能是：关闭 Nagle 算法或者关闭 TCP 延迟确认。









# 参考资料

 - [Java面试知识点总结-计算机网络](https://blog.nowcoder.net/n/aae672c111664b029b49d88dd22af492)
 - [TCP粘包/拆包问题](https://www.cnblogs.com/wade-luffy/p/6165671.html)
 - [流量控制](https://www.cnblogs.com/kubidemanong/p/9987810.html)
 - [TCP半打开连接及同时打开同时关闭](https://blog.csdn.net/wdscq1234/article/details/52422657)
 - [TCP中的四个计时器](https://blog.csdn.net/qq_33951180/article/details/60468267)
 - [传输层TCP和UDP的区别分析与应用场景](https://blog.csdn.net/u013777351/article/details/49226101)
 - [实战！敖丙用“大白鲨”让你看见 TCP](https://mp.weixin.qq.com/s/jTDU-zxP1INTYLpGLypjXQ)
 - [linux服务器出现大量TIME_WAIT](https://my.oschina.net/u/4283892/blog/3307668)