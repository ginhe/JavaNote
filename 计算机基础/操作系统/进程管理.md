# 计算机硬件

在概念上，一台简单的个人电脑可分为如下模型：

![](https://user-gold-cdn.xitu.io/2020/7/6/17322b105ac70699?w=641&h=232&f=png&s=35561)

**（1）CPU**

它主要和内存进行交互，从内存中提取指令，解码并决定它的类型和操作数，然后执行。

每个CPU 都有一组可以执行的特定指令集：x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些`寄存器`来保存关键变量和临时结果，此外还要一些特殊的寄存器：

- 程序计数器：指示下一条需要从内存提取指令的地址。
- 堆栈指针：包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。

**（2）内存**

它主要用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。它是外存与CPU进行沟通的桥梁，计算机中所有程序的运行都是在内存中进行的，

理想情况下的内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求，因此存储器系统采用一种分层次的结构

![](https://user-gold-cdn.xitu.io/2020/7/6/17322bde75870768?w=450&h=252&f=png&s=41984)

**（3）输入输出设备**

输入设备的任务是把人们编好的程序和原始数据送到计算机中去，并且将他们转换成计算机内存所能识别和接受的信息方式。

输出设备的任务是将计算机的处理结果以人或其他设备所能接受的形式送出计算机。



# 操作系统

程序员无需直接和上述的计算机硬件打交道，因为在硬件的基础之上，计算机还安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，这种软件称之为 **操作系统**。它是管理计算机硬件与软件资源的系统软件，需要处理**管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务**，同时也提供一个让用户与系统交互的操作界面。

## 用户态和内核态

下图是Linux整体架构图

<img src="https://img-blog.csdnimg.cn/20200311181818822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

**用户态和系统态**

计算机系统通常允许着系统程序和应用程序。为了安全和稳定性，操作系统的程序不能随便访问。因此CPU存在两种工作状态：用户态和系统态。

- 内核态：运行操作系统程序，操作硬件
- 用户态：运行用户程序的

对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。

- 当进程执行系统调用而陷入内核代码中执行时，我们就称进程处于内核态。此时处理器在内核代码中执行，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

- 当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在用户代码中运行。


为了使应用程序访问到内核管理的资源，例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**

系统调用可分为：

- 设备管理。完成设备的请求或释放，以及设备启动等功能。
- 文件管理。完成文件的读、写、创建及删除等功能。
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
- 进程通信。完成进程之间的消息传递或信号传递等功能。
- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能

**用户态什么时候转到内核态**

（1）系统调用

用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。

（2）异常

CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常（比如缺页异常），这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态。

（3）外围设备的中断

当 外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

> 系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

**shell**

对于图形界面，用户点击某个图标就能启动某个程序；对于命令行，用户输入某个程序的名字（可以看做一个命令）就能启动某个程序。这两者的基本过程都是类似的，都需要查找程序在硬盘上的安装位置，然后将它们加载到内存运行。然而，真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和命令行只是架设在用户和内核之间的一座桥梁。

由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核了。在Linux下，这个命令行程序叫做 **Shell**。





# 进程管理

## 进程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」。

简单的理解，进程就是计算机中正在运行的程序。**它是系统进行资源分配度的基本单位。**进程可由系统，父进程创建。

**特性**

- 进程是程序的动态运行过程，有生命周期; 
- 多个进程实体同存于内存中，且能在一段时间内同时运行;
- 各进程的地址空间相互独立，但它们之间可以通信；

**进程的构成**

它包含代码段，数据段，进程控制块PCB，而**PCB 是进程存在的唯一标识**

进程控制块PCB描述了进程的基本信息和运行状态，它是系统对进程管理的依据，系统将其按一定的方式存放在内存的系统区，而程序和数据放在内存的用户区。所谓的创建和撤销进程，都是对PCB的操作。

**进程的状态**

（1）运行态：进程正占用处理机执行。

（2）就绪态：进程具备运行条件，一旦得到处理器资源即可运行。

（3）阻塞态：进程因等待某事件发生(如I/O操作结束)或某资源 而暂时不能运行的状态。

（4）创建状态：进程被创建的第一个状态。

​		首先申请空闲的PCB，指定PID。然后为新进程分配资源；将新进程的PCB初始化后，将新进程加到就绪队列中

（5）结束状态：进程已经运行完成或出错时，会被操作系统作结束状态处理；

​		首先从系统的PCB表中找到指定进程的PCB。回收该进程占用的全部资源。若该进程还有子孙进程，回收它们所占有的全部资源。释放被终止进程的PCB，并从原来队列中拿走。



### 进程通信

有些复杂程序需要多个进程共同完成，进程之间需要交换数据，但是各自进程有不同的用户地址空间，任何一个进程的全局变量对于另一个进程是不可见的，因此进程之间交换数据需要通过内核：在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走。内核提供的这种机制称为**进程通信**。

进程的通信方式主要有：管道，消息队列，信号量，套接字。

**（1）匿名管道**

匿名管道是特殊的文件，只存在于内存，不存于文件系统中。管道的实质是一个内核缓存区，进程以先进先出的方式从内核存/取数据。

比如linux命令`ps auxf | grep mysql`里的 |这个竖线，它在这里的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从这功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行。这种没有命名的管道称为匿名管道，用完就销毁。

管道是通过调用 pipe 函数创建的，它会返回两个描述符：fd[0] 用于读，fd[1] 用于写。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fcf76bd2e649aba3310e6c77b6d7af~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

这两个描述符都是在一个进程里面的，我们可以使用`fork`创建子进程，子进程会复制**父进程的文件描述符**，这样就做到了两个进程各有两个「 `fd[0]` 与 `fd[1]`」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc4f3816ca9470e9e2e7955b8aff71d~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

通常父子进程会分别只保留1个描述符作为读或者写：

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/297652c8e7cc46a1abde73a5e57b4143~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

当我们在shell执行`A|B`时，A进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d860b431b9244f4a0ab6a802b119ef5~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />**

**特点**

- 匿名管道只允许具有血缘关系的进程通信（如父子进程）。
- 管道只能单向流动。
- 管道传送的是无格式字节流。
- 生命周期随进程的创建而建立，随进程的结束而销毁。

**（1-1）命名管道FIFO **

命名管道以磁盘文件的形式存在于文件系统中。即便进程间不存在亲缘关系，只要进程使用这个设备文件，也可以与其他进程相互通信。

FIFO 常用于客户-服务器应用程序中：每一个客户端必须预先知道服务器提供的FIFO接口，服务器适时监控着命名管道的读端，当有数据时，读出并进行处理。

![img](https://img-blog.csdnimg.cn/20200311103323435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

***如何使用命名管道？***

我们可以使用`mkfifo myPipe`命令来创建一个名为myPipe的管道，我们可以通过命令`ls -l`单列查看文件：

```
ls -l
prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
```

然后往管道里写数据：

```
 echo "hello" > myPipe  // 将数据写进管道
                         // 停住...
```

只有当管道里的数据被读完后，命令才可以正常退出。因此我们执行另一个命令来读取这个管道里的数据：

```
$ cat < myPipe  // 读取管道里的数据
hello
```

管道的**通信方式效率低，不适合进程间频繁地交换数据**。但它简单。



**（2）消息队列**

消息队列是保存在内核的消息链表。在发送数据时，会分成一个一个独立的消息体，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型。

消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，不会随着进程的结束而销毁。

**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。并且在**通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。



**（3）共享内存**

现代操作系统采用的虚拟内存的技术来管理内存：每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，从而解决了队列中内核态和用户态的数据开销问题，大大提高了进程间通信的速度。

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7754aaabe39447e7b873179030d1ce34~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />



**（3）信号量**

共享内存通信方式存在一个问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。为了保证共享资源在任意时刻只能被一个进程访问，便有了信号量。

信号量是一个计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。

**（4）信号**

上面说的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

> 在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 `kill -l` 命令，查看所有的信号。

信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）:

- 运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如
  -  Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
  - Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；

- 如果进程在后台运行，可以通过 `kill` 命令加上进程的端口给进程发送信号



信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

- **执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。
- **捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
- **忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。







**（4）套接字**

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**

> Socket 通信也可以在同主机上进程间通信。

创建Socket的类型有三种：

（4-1）**针对 TCP 协议通信的 socket** 

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9abef9e811414d3c8656efb678062754~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />

简述一下上图流程：

- 服务端和客户端初始化 `socket`，得到文件描述符；
- 服务端调用 `bind`，将绑定在 IP 地址和端口。然后 `listen`，进行监听；最后调用 `accept`，等待客户端连接；
- 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；
- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；
- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。

需要说明的是：在连接成功后，服务端调用 `accept` 会返回一个已完成连接的 socket，后续用来传输数据。因此有一个socket负责监听。一个socket负责传输数据。

> 通信的数据是数据报

（4-2）**针对UDP协议通信的Socket**

UDP 不需要三次握手，也就不需要像 TCP 调用 listen 和 connect。不需要维护连接意味没有所谓的发送方和接收方，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。此外每次通信时，调用的 sendto 和 recvfrom来发送和接收数据都要传入目标主机的 IP 地址和端口。

> 通信的数据是原始套接字



（4-3）**针对本地进程通信的Socket**

本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**。

通信的数据有本地字节流和本地数据包。



### 进程互斥

**信号量S**

若S≥0，表示可用资源个数，反之则为等待资源的进程个数。初始值由系统给定且只能通过P,V操作改变其值。

**P,V操作（原语）**

P(S)表示有进程请求资源。它将信号量S减1，若S≥0，该进程继续执行，否则将该进程置为阻塞态，将其PCB连入该信号量队列的末尾并等待。

V(S)表示有进程释放资源。它将S值加1，若S＞0，该进程继续执行，否则唤醒信号量队列上第一个PCB，然后该进程继续执行。

<img src="https://img-blog.csdnimg.cn/20200304135923390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 进程同步

多个合作进程为完成同一任务，它们在执行速度必须相互协调。即一个进程的执行依赖于另一个进程的消息，当没有消息时等待，直到消息到达时被唤醒。等待方执行P操作，测试消息是否到达；发送方执行V操作，表示发送消息。

**生产者与消费者问题**

问题描述：缓冲区共有N个位置，任意时刻只能有一个进程对缓冲区操作。

我们采用信号量机制：定义初值为N的empty值，表示缓冲区中空位的数目；定义初值为0的full值，表示缓冲区中可供消费资源的数目；定义用于访问缓冲区时的互斥的mutex值，初值为1。

```
生产者：

P(empty);  //首先判断是否有空位

P(mutex);  //尝试进入缓冲区

//生产过程

V(mutex);

V(full);  //可供消费资源数加1
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

```
消费者：

P(full);      //判断是否资源

P(mutex);    //尝试进入缓冲区

//生产过程

V(mutex);

V(empty);    //通知生产者已消费
```

> 注：每个进程各个P操作的次序非常重要，即要先检查资源数目，再检查访问缓冲区是否互斥。否则可能造成死锁。

**哲学家就餐问题**

<img src="https://img-blog.csdnimg.cn/20200304142131298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



<img src="https://img-blog.csdnimg.cn/20200304142234668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

**算法**

<img src="https://img-blog.csdnimg.cn/20200304145005260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

也就是说哲学家1和哲学家2争抢筷子2，哲学家3和哲学家4争抢筷子4，哲学家5争抢筷子1

可能出现的情况：首先哲学家5肯定抢到了筷子5

- 如果哲学家1抢到了筷子2，则哲学家2等待哲学家1释放筷子2，哲学家1等待哲学家5释放筷子1。
  - 如果哲学家4抢到了筷子4，则哲学家3等待哲学家4释放筷子4，哲学家4和哲学家5争抢筷子5。
  - 如果哲学家3抢到了筷子4，则哲学家4等待哲学家3释放筷子4。哲学家3拿到筷子3后开吃，哲学家5拿到筷子5后开吃。
- 如果哲学家2抢到了筷子2，则哲学家1等待哲学家2释放筷子2。
  - 如果哲学家4抢到了筷子4，则哲学家3等待哲学家4释放筷子4。哲学家4和哲学家5争抢筷子5，哲学家2拿到筷子3后开吃
  - 如果哲学家3抢到了筷子4，则哲学家4等待哲学家3释放筷子4。哲学家3和哲学家2争抢筷子3，哲学家5拿到筷子5后开吃。

也就是说，最坏情况下肯定有一个哲学家可以抢到筷子。

### 进程调度

进程调度负责协调和控制各进程对CPU的使用，按一定的调度原则和某种调度算法从就绪队列中选择的一个进程，把CPU分配给该进程运行。

#### 调度算法

**先来先服务算法**

非抢占式的调度算法，按照请求的顺序进行调度。

- 优点：实现简单；不考虑进程的特性。
- 缺点：效率较低；利于长作业，不利于短作业。

**最短作业优先法**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

- 优点：作业平均等待时间最小，作业吞吐重量大。
- 缺点：若系统不断接纳新作业，可能导致大作业长期等待。

**最短剩余时间优先算法**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**时间片轮转法**

1. 进程就绪队列往往按到达的时间来排序
2. 调度程序按先来先服务原则调度就绪队列中第一个进程。
3. 进程占用处理仅使用一个时间片，使用完后，该进程释放处理机给下一个就绪的进程并返回就绪队列末尾。
4. 最佳的时间片值应考虑处理及能力，各终端任务的急迫程度等方面因素。

**优先级调度算法**

为每个进程分配一个优先级，按优先级进行调度





## 线程

线程是进程的一条执行流程，它是CPU调度的单位。

### **特征**

- 同属一个进程的其他线程共享该进程拥有的全部资源；
- 同一进程中的多个线程可并发执行，不同进程中的线程也能并发执行。
- 在引入线程的OS中，资源分配的对象是进程。调度的基本单位是线程，处理器是分给线程的，真正在处理器运行的是线程。

**为什么要引入线程**

（1）应用的需要

比如说Web服务器，服务器需要做如下操作：

1. 从客户端接收网页请求；
2. 从磁盘中搜索相关网页，读入内存；
3. 将网页返回给对应客户端

由于进程只能在同一时间执行一个程序执行流，因此我们便引入线程来执行不同的程序执行流

（2）开发的需要

进程的创建，撤销以及通信的开销要比线程大，且线程之间通信无调用内核（同一进程内的线程共享内存和文件）。限制了并发度，而线程的开销要少。

### 线程共享/独享的资源

线程共享了进程的一些资源：

- 堆：由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的。
- 全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
- 静态变量：虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
-  文件等公用资源： 这个是共享的，使用这些公共资源的线程必须同步。

线程私有的资源：

- 栈
- 寄存器，程序计数器PC

### 线程的实现

**1.线程实现在用户空间**

用户线程是基于用户态的线程管理库来实现的，操作系统只能看到进程，不能看到线程。在OS看来，每个进程只有一个线程。因此OS不直接参与用户线程的整个线程管理和调度，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。

用户线程的模型是多个用户线程对应同一个内核线程

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eba13f194ca4f24b67b2de9394cb1a9~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

**优点**

- 线程调度是在用户态进行的，减少了OS从内核态到用户态的切换开销
- 用户级线程可以在不支持线程的操作系统上实现
- 允许每个进程有自己定制的调度算法

**缺点**

- 由于OS不知道线程的存在，因此当一个进程中的某一线程进行系统调用时，如果发生了阻塞（如缺页中断），则OS会阻塞整个进程，即便这个进程里的其他线程还在工作。
- 如果进程中的一个线程长时间不释放CPU，由于用户空间并没有时钟中断机制，因此会导致进程中的其它线程得不到 CPU 而持续等待。



**2.线程实现在内核空间**

内核线程是直接由操作系统内核支持的线程，这种线程的创建、终止和管理都是由操作系统负责。

内核线程的模型是：一个用户线程对应一个内核线程。

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f22d90f31f5a49969f2b6367aabe22ea~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> 图中的K是内核线程，P是进程

**优点**

- 程序员可以直接使用操作系统中已实现的线程，而线程的创建、销毁、调度和维护，都是靠操作系统（准确的说是内核）来实现，程序员只需要使用系统调用，而不需要自己设计线程的调度算法和线程对 CPU 资源的抢占使用。
- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；

**缺点**

- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；
- 每个用户线程都需要有一个内核线程支持，这会消耗内核空间。

**轻量级进程LWP**

它是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。此外LWP 只能由内核管理并像普通进程一样被调度，它与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。

LWP模型有三种：

- 一个线程对应到一个 LWP 再对应到一个内核线程。
- 多个用户线程对应一个 LWP 再对应一个内核线程
- 前两者混搭在一起形成M:N模型：多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程



<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97abc334617e43188c91dc7172be7bcd~tplv-k3u1fbpfcp-zoom-1.image" style="zoom: 67%;" />





**3.混合模式**

现代操作系统将上述两种实现结合在一起：

- 用户线程还是完全建立在用户空间里，因此用户线程的操作开销仍旧较低；
- 轻量级进程则是作为用户线程和内核线程之间的桥梁，它是内核的调度单元，并且用户线程的系统调用要通过轻量级进程，因此进程中某个用户线程的阻塞不会影响整个进程的执行。当内核调度到某个轻量级进程时，与该轻量级进程管理的用户线程就被执行。

![img](https://img-blog.csdnimg.cn/20200424144437620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

> 图中的K是内核线程，LWP是轻量级进程，U是用户线程。

### 线程的同步方式

**互斥量：**只有拥有互斥对象的线程才能访问公共资源。如Java中的synchronized 关键字和Lock。

**事件：**通过通知/唤醒方式来保持多线程同步，如Java中的Wait/Notify方法。

**信号量：**它允许在同一时刻里，多个线程访问统一资源，需要定义最多能访问的线程数量。

# 死锁

## 死锁产生的原因

**系统资源不足**

系统中存在两个或多个进程，它们中的每一个进程都占用了某种资源，且又都等待着其中另一个进程所占用的资源而无限期的僵持下去的局面。

**进程并发执行的顺序不当。**

信号量使用不当也会造成死锁，如下图为例，可能会出现：P1占有S1资源，等待S2；P2占有S2资源，等待S1。使得P1，P2永久等待。

<img src="https://img-blog.csdnimg.cn/20200304190706368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70" alt="img" style="zoom:33%;" />![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



**死锁产生的必要条件**

1.互斥条件：资源使用互斥。

2.不可抢占条件：进程所获得的资源在未完毕之前，申请者不能强行从占有者夺取资源。

3.占有等待条件：进程在所占用的资源未使用完前，又申请其他进程所占用的资源

4.循环等待条件：资源分配图中存在链路。

> 注：只要死锁发生，这四个条件必然同时成立，反之则不然。





## 死锁的预防

思想：破坏死锁四个必要条件中的一个

**1.互斥条件不可破坏。**

**2.破环不可抢占条件（适用于内存及处理机）**

若进程P1申请的资源R1正被进程P2占用，则检查P2的状态，若P2处于等待另一资源的状态，则抢夺R1并分配给P1。否则让P1处于等待R1的状态。

**3.破坏占用且等待条件**

一个进程在执行前就申请它所需的全部资源，全部满足后才开始执行。

**4.破坏循环等待的条件**

实行资源有序分配策略

1）把全部资源事先按类编号。

2）进程申请不同资源时，严格按资源编号递增顺序申请。

3）进程只有在小编号资源的申请得到满足后，才能申请大编号资源。



## 死锁的避免（银行家算法）

### 安全状态

![img](https://img-blog.csdnimg.cn/20200311104259264.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- 如上图所示，图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。
- 从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态是安全的。

### 银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

（1）

![img](https://img-blog.csdnimg.cn/20200311104609805.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

上图的c为不安全状态。

（2）

![img](https://img-blog.csdnimg.cn/20200311104736598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjgxODMw,size_16,color_FFFFFF,t_70)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

上图中有五个进程，四个资源，左图表示已分配的资源比例数，右图表示所需资源比例数。字母E，P，A分别表示总资源比例，已分配资源比例和可用资源比例。

- 检查右图的所需资源比例数是否存在一行（进程）中所有数都小于可用资源比例A，若不存在这一个进程，则说明每个进程所需资源数全部大于当前剩余可用的资源数，因此系统会发生死锁。
- 若存在，将该行去掉，并将已分配资源比例加入A中对应的比例（进程释放资源）；
- 重复以上步骤，若所有进程都被去掉，则状态安全





# 参考资料

[进程与线程](https://mp.weixin.qq.com/s/FaHKGRI69TqDj0AJtNiVoA)

[进程的通信方式](https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA)