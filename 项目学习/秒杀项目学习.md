# Spring

## 属性检查

之前在service层实现的注册功能里 首先要对 输入框里输入的信息组成的userModel进行检查

```java
//com.jnju.service.impl.UserServiceImpl

	@Override
    @Transactional
    public void register(UserCompleModel userModel) throws BusinessException{
        if(userModel == null) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
        }
        if(StringUtils.isEmpty(userModel.getName()) || userModel.getGender() == null ||
                userModel.getAge() == null || StringUtils.isEmpty(userModel.getTelephone())) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
       }

        //...
    }
```

我们可以通过javax validation类简化 这段对userModel属性检查的代码

首先引入依赖：

```xml
        <!-- hibernate-validator -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
            <version>6.0.17.Final</version>
        </dependency>
```



（1）设置了一个存储错误信息的类ValidatorResult

```java
package com.jnju.validator;
public class ValidatorResult {
    private boolean hasErrors = false;
    private Map<String, String> errMsgMap = new HashMap<>();
	//getter，setter

    public String getErrMsg() {
        //逗号分隔的字符串
        return StringUtils.join(errMsgMap.values().toArray(), ",");
    }
}
```

（2）一个检查是否有错误信息的类ValidatorImpl，它继承自InitializingBean接口，并实现为bean提供了属性初始化后的处理方法afterPropertiesSet。凡是继承该接口的类，在bean的属性初始化后都会执行该方法。

```java
import javax.validation.Validation;
import javax.validation.Validator;

@Component
public class ValidatorImpl implements InitializingBean {
    private Validator validator;

    public ValidatorResult validate(Object bean) {
        ValidatorResult result = new ValidatorResult();
        Set<ConstraintViolation<Object>> constraintViolations =  validator.validate(bean);
        if(constraintViolations.size() > 0) {
            result.setHasErrors(true);
            //遍历constraintViolations里的每一个元素constraintViolation
            constraintViolations.forEach(constraintViolation->{
                String propertyName = constraintViolation.getPropertyPath().toString();
                String errMsg = constraintViolation.getMessage();
                result.getErrMsgMap().put(propertyName, errMsg);
            });
        }
        return  result;
    }

     @Override
    public void afterPropertiesSet() throws Exception {
        this.validator = Validation.buildDefaultValidatorFactory().getValidator();
    }
}
```

（3）设置参数检查

```java
/*
    UserDao只是对应数据表user，
    实际的用户模型里还包括密码encrptPassword
*/
public class UserCompleModel {
    private Integer id;
    @NotBlank(message = "用户名不能为空")
    private String name;
    @NotNull(message = "性别必须填写")
    private Byte gender;
    @NotNull(message = "年龄必须填写")
    @Min(value = 0, message = "年龄必须大于0")
    @Max(value = 200, message = "年龄必须小于200")
    private Integer age;
    @NotBlank(message = "电话不能为空")
    private String telephone;

    private String registerMode;

    private String thridPartyId;
    @NotBlank(message = "密码不能为空")
    private String encrptPassword;
    //...
}
```

（4）在代码中判断参数的值是否正确。

```java
//com.jnju.service.impl.UserServiceImpl

	@Override
    @Transactional
    public void register(UserCompleModel userModel) throws BusinessException{
        if(userModel == null) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
        }
//        if(StringUtils.isEmpty(userModel.getName()) || userModel.getGender() == null ||
//                userModel.getAge() == null || StringUtils.isEmpty(userModel.getTelephone())) {
//            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
//        }
        //代替上面注释代码的判断
        ValidatorResult result = validator.validate(userModel);
        if(result.isHasErrors()) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, result.getErrMsg());
        }
        //...
    }
```



## 跨域请求

**什么是跨域请求**

在 HTML 中，`<a>`, `<form>`, `<img>`, `<script>`, `<iframe>`, `<link>` 等标签以及 Ajax 都可以指向一个资源地址，而所谓的**跨域请求**就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。

**示例**

我们的后端程序和前端是独立在两个不同文件夹上的。此处以申请验证码getotp页面为例，当我们点击注册按钮，发起一个ajax请求时：

```javascript
 $.ajax({
                type:"POST",
                contentType:"application/x-www-form-urlencoded",
                url:"http://localhost:8080/user/getotp",
                data:{
                    "telphone":$("#telphone").val(),
                },
                //允许跨域请求
               // xhrFields:{withCredentials:true},
                success:function (data) {
                    if (data.status=="success") {
                        alert("otp已经发送到了您的手机，请注意查收");
                        window.location.href="register.html";
                    }else {
                        alert("otp发送失败，原因为" + data.data.errMsg);
                    }
                },
                error:function (data) {
                    alert("otp发送失败，原因为"+data.responseText);
                }
            });
```

后端接口`User/getotp`虽然成功执行了，但页面上显示的是otp发送失败。查看一下错误信息：

![](https://user-gold-cdn.xitu.io/2020/7/26/17388f1eea903364?w=1789&h=46&f=png&s=88966)

这个就是跨域请求问题：ajax请求所在资源对应的域是本地文件，但是我们请求的后台接口是localhost域名。虽然请求能够到达后台接口，并且接口可以返回，但ajax认为两者的域不同，因而走不到ajax里的success block里面。

**后端**

在后端上，Springboot提供了一个@CrossOrigin注解 来开启CORS，它可以在每次的响应头上添加`Access-Controller-Allow-Origin`字段，其值为*。这样的web应用会被准许访问在本地文件上的html资源。

```java
@CrossOrigin(origins = {"*"},allowCredentials = "true")
//或者这样：@CrossOrigin(allowCredentials="true", allowedHeaders = "*")
```

origins = {"*"}表示允许可访问的域列表

allowCredentials="true"其实是配置了CrossOrigin中的DEFAULT_ALLOWED_HEADERS：这样可以实现跨域的session共享。

> **什么是CORS**
>
> 跨域资源共享CORS是一种机制，它使用额外的HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。

**前端**

我们还要在每个ajax请求里配置xhrFields属性，它会将该ajax的请求变为一个允许跨域授信的请求。

```
 xhrFields:{withCredentials:true}
```







# 数据库

## 设计表

### 三种模型类

在数据库的设计中，用户信息拆分为用户信息表和用户密码表；商品信息拆分为商品信息表和商品库存表。

对应在后台的模型类中，我们将这两个信息的每个都拆分成3个模型类：

（1）在model包下的数据库模型类：ItemDo，ItemStockDo，UserDO，UserPasswordDO。这些类对应数据库里的表，mabatis里传入的参数都是该模型类

（2）在model包下的信息模型类，比如ItemModel，UserModel。它是被拆分的两个表的结合类，但它的一些属性和数据库模型类不同：

- `ItemModel.price`是BigDecimal类型，而`ItemDO.price`是Double类型；java里的Double在前端展示会出现精度问题，因此使用BigDecimal。
- `PromoModel.promoItemPrice`是BigDecimal类型，而`PromoDO.promoItemPrice`是Double类型；
- `PromoModel.startDate`和`PromoModel.endDate`是DateTime类型，而`PromoDO.startDate`和`PromoDO.endDate`是Date类型的。

（3）在viewObject包下的以Vo为后缀名的视图模型类，比如ItemVo等。这是我们用于规定模型类的哪些属性是需要展示在前端页面上，我们在控制层上返回这些模型类对象给前端。对于数据模型类里类型是Double的字段，视图模型类的字段类型和信息模型类一样，也是BigDecimal类型。

但对于活动商品的视图模型类的时间属性startDate，则是String类型。这是因为如果是DateTime属性在json数据化时，会出现错误：

![](https://user-gold-cdn.xitu.io/2020/7/27/1738f615b820902a?w=281&h=398&f=png&s=114635)



### 订单流水号

在订单表order_info里，其字段id不是递增的，而是我们自己自定义的订单流水号。

```java
/*
        * @param:
        * @description: 生成16位订单号。该方法包裹在事务方法createOrder里面。
        *               如果方法createOrder回滚，那么SequenceInfoDao的值也会跟着回滚
        *               但我们不希望值回滚，因此我们可以使用propagation属性的REQUIRES_NEW字段
        *               该字段表示无论该方法是否在事务中，它都会开启一个事务，并在执行完后提交事务。
        * @return: java.lang.String
    */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private String generateOrderNo() {
        //前8位是时间信息：年月日
        StringBuilder orderId = new StringBuilder();
        LocalDateTime now = LocalDateTime.now();
        String nowDateStr = now.format(DateTimeFormatter.ISO_DATE).replace("-", "");
        orderId.append(nowDateStr);

        //中间6位是自增序列
        int sequence = 0;
        SequenceInfoDao sequenceInfoDao = sequenceInfoDaoMapper.getSequenceByName("order_info");
        sequence = sequenceInfoDao.getCurValue();
        //下一次获取的值是步长step加上当前值
        sequenceInfoDao.setCurValue(sequenceInfoDao.getCurValue() + sequenceInfoDao.getStep());
        sequenceInfoDaoMapper.updateByPrimaryKeySelective(sequenceInfoDao);
        //不足6位的补0
        String sequenceStr = String.valueOf(sequence);
        for(int i=0; i<6-sequenceStr.length(); i++) {
            orderId.append(0);
        }
        orderId.append(sequenceStr);
        //最后2位是分库分表位。
        orderId.append("00");

        return orderId.toString();
    }
```

此处订单id是我们自定义的流水号，它由8位时间信息+自增序列+分库分表位组成。

其中流水号的自增序列涉及到数据表sequence_info。每当新增一个流水号时，都会从该表里的数据表名name对应的记录里提取出curValue作为其中间6位数（不足补0），然后下一次的curValue就等于curValue+step（无论添加订单的事务操作是否是执行还是回滚，它都会加上step）。

```java
/*
	CREATE TABLE `sequence_info`  (
      `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
      `current_value` int(11) NOT NULL DEFAULT 0,
      `step` int(11) NOT NULL DEFAULT 0,
      PRIMARY KEY (`name`) USING BTREE
    ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Compact;
    INSERT INTO `sequence_info` VALUES ('order_info', 6, 1);
*/
public class SequenceInfoDao {
    private String name;		//涉及到的表名，此处是order_info

    private Integer curValue;

    private Integer step;
    //getter，setter
}
```

**for update**

在通过表名name获取sequence_info记录时，需要加上行级锁，也就是for update。

```sql
  <select id="getSequenceByName" parameterType="java.lang.String" resultMap="BaseResultMap">
    select 
    <include refid="Base_Column_List" />
    from sequence_info
    where name = #{name,jdbcType=VARCHAR} for update
  </select>
```

它会把查询到的数据加上锁，其他事务无法对其进行更新。等到事务提交了才释放锁。





## insertSelective和insert

在自动生成的mapper映射文件里，有两个添加操作的sql语句：insertSelective和insert。

（1）insertSelective会在添加操作前检查传进来的UserDao对象里的对应字段是否为 null：如果为null则不添加该字段，也就是取决于数据库里的默认值。

（2）insert操作不会检查字段是否为null，也就是如果为null，则会覆盖掉数据库的默认值。





## useGeneratedKeys和keyProperty

当我们要在程序里使用到自增id时，比如说：

```java
        UserDao userDao = convertToUserDao(userModel);
        try {
            userDaoMapper.insertSelective(userDao);
        }catch (DuplicateKeyException e) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "手机号已重复");
        }
        userModel.setId((userDao.getId()));
```

我们要在映射文件里指定自增的id：

```
  <insert id="insertSelective" parameterType="com.jnju.model.UserDao" keyProperty="id" useGeneratedKeys="true">
```



## 唯一索引telephone

注册功能的实现需要电话号码，为了保证每条记录里telephone字段的唯一性，我们需要将其设置为唯一索引。

如果在添加注册用户的insertSelective方法中出现了DuplicateKeyException异常，则表示添加的唯一性索引字段telephone与数据库里原有的记录有重复。

```java
        try {
            userDaoMapper.insertSelective(userDao);
        }catch (DuplicateKeyException e) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "手机号已重复");
        }
```



# jmeter工具

[jmeter](https://jmeter.apache.org/download_jmeter.cgi)是一个压力测试工具，你可以通过它来模拟多线程对某一接口的请求并查看其输出接口。

新建步骤：

- 右键测试计划->添加->线程->线程组。
- 右键线程组->添加->取样器->HTTP请求。
- 右键线程组->添加->监听器->查看结果树
- 右键线程组->添加->监听器->聚合报告。

下面来看一下上述四个功能。

（1）线程组。其中线程数表示并发的线程数x；Rampu-Up时间表示在该时间内启动x个线程；循环次数表示每个线程发起的请求数量。

你可以通过上方的绿三角形来启动，右边的符号可可以清空上次请求的记录。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a35937ace805?w=1527&h=666&f=png&s=48118)



（2）HTTP请求。你可以在此规定请求协议，类型以及服务器的IP（或域名）和端口

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a405889534a5?w=1529&h=601&f=png&s=52312)

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a406476857ce?w=1521&h=556&f=png&s=48801)



察看结果树。你可以在此观察到响应的返回内容。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a434e5cdbfa2?w=1516&h=494&f=png&s=49220)



（4）聚合报告。你可以在此检查所有请求的数据。比如说响应时间的平均值，中位值和90%，95%，99%的响应时间等等。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a3587dad87c0?w=1515&h=512&f=png&s=41407)



# 项目出现的问题

## 并发容量问题

**模拟场景**

通过jmeter工具来启动超多个线程：

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a46ed72c7aaa?w=1520&h=604&f=png&s=222875)

发起对服务器的get请求：

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a47762c5d95b?w=1510&h=477&f=png&s=182123)

运行后会发现响应数据出现了错误。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a46e4f3e80bd?w=1483&h=694&f=png&s=528710)

通过下面命令

```
ps -ef | grep java 查看正在进行的java线程

pstree -p java进程号 | wc - l 统计java进程下的线程数
```

我们可以得知在服务端下java进程下最多有x个线程，最多服务于x个线程。而5000个线程远大于x，从而导致请求被拒绝。

**解决方案**

我们可以在配置文件application.properties中对springboot的内嵌tomcat进行一些配置：

```
server.tomcat.accept-count 				等待队列长度，默认100

server.tomcat.max-connections:			最大可被连接数，默认10000

server.tomcat.max-threads				最大工作线程数，默认200

server.tomcat.min-spare-threads			最小工作线程数，默认10

默认配置下，连接超过10000后出现拒绝连接情况

默认配置下，触发的请求超过200(工作线程)+100（等待队列）后拒绝处理
```



## keep alive问题

**什么是KeepAlive**

对于非KeepAlive模式：每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；

当使用Keep-Alive模式（持久连接）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

[![HTTP_persistent_connection.svg](https://byvoid.com/attachments/wp/2011/07/450px-HTTP_persistent_connection.svg_.png)](https://byvoid.com/attachments/wp/2011/07/450px-HTTP_persistent_connection.svg_.png)

> http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive”，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive。

**keep alive问题**

如果服务端对keep alive没有限制时间，那么可能出现一些问题：

- 客户端将网页空闲，不去做任何响应。那么这条连接对于服务端来说就是废连接
- 攻击者恶意利用keep alive发起DDOS攻击

**解决方案** 

因此我们需要定制化内嵌Tomcat，我们需要关注两个参数：

```
keepAliveTimeOut		多少毫秒后不响应的断开keepalive
maxKeepAliveRequests	多少次请求后keepalive断开失效
```

这两个参数不是在配置文件里定义的，而是使用`WebServerFactoryCustomizer<ConfigurableServletWeb ServerFactory>`定制内嵌tomcat配置：

```java
package com.jnju.miaosha_project.config;
/*
    当springboot启动后，会将server.tomcat的参数加载到protocol内，然后又会组装到
    ConfigurableWebServerFactory对象里
*/
@Component
public class WebServerConfiguration implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
    @Override
    public void customize(ConfigurableWebServerFactory factory) {
        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(new TomcatConnectorCustomizer() {
            @Override
            public void customize(Connector connector) {
                Http11NioProtocol protocol = (Http11NioProtocol)connector.getProtocolHandler();

                //30秒内没有请求则服务端自动断开keepalive连接
                protocol.setKeepAliveTimeout(30000);
                //当客户端发送超过10000个请求则自动断开keepalive连接
                protocol.setMaxKeepAliveRequests(10000);
                protocol.setM
            }
        });
    }
}
```



## 单Web容器上限

虽然前面我们增加了tomcat的线程，变更了线程池以及对keep-alive做了优化，但容量问题依旧存在。随着并发容量压力的增大，HTTP请求的响应时间随之变长，吞吐量（每秒处理完的请求数）在达到一定值后就会无法上升。

对于单Web容器上限，我们考虑两个角度：

（1）线程数量：当进程调度的线程数达到一定值后（比如4核cpu 8G内存单进程调度线程数为800-1000），如果超出这个值，CPU的大量时间将会消耗在线程调度和cpu的内存切换。因此线程数不是越多越好。

（2）等待队列长度：如果并发请求线程数超过了最大线程池时，那么就会进入等待队列。队列的长度不能无限长，因为对应的缓冲区是消耗内存的，出队和入队也消耗cpu。

如果线程数超出了上述两个的正常范围，我们应该将单台web容器扩展为多台。



## Mysql的查询效率

- 主键查询：千万级别数据 = 1-10ms
- 唯一索引查询：千万级别数据 = 10-100ms
- 非唯一索引查询：千万级别数据 = 100-1000ms
- 无索引：百万条数据 = 1000ms +

我们要保证查询操作尽可能是在唯一索引，甚至是主键查询上，如果前两者无法保证，比如根据订单状态查询订单表，那么订单状态就必须是非唯一索引查询，如果是无索引查询相当于全表查询，这种方式对于大型应用来说是不可接受的。

如果数据库里数据达到了千万级别后，非唯一索引查询也会产生一定的压力，此时我们就需要考虑分库分表，扩容热点数据。



## 水平扩展

之前的部署方式是将web容器同时部署了jar包和mysql服务器，也就是说：web容器不仅要服务于mysql数据库，还要服务于应用服务器。

<img src="https://user-gold-cdn.xitu.io/2020/7/30/1739d400da9c71b9?w=792&amp;h=642&amp;f=png&amp;s=96713" style="zoom:67%;" />



我们可以水平部署应用服务器，单点存储数据库，此处我们需要一台nginx来做反向代理的负载均衡。总的来说，分布式部署需要一台数据库服务器，一台nginx服务器，两台应用服务器。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dabf4cf1925242baba60df438fcb99cf~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />



## 多个应用服务器出现的session不一致

在前面我们将jar包部署在两个应用服务器中，并用nginx反向代理到这两个应用服务器中。

在该程序中，程序会在用户登陆后，将IS_LOGIN放在session里。当页面执行创建订单功能createOrder方法时，首先会通过session里IS_LOGIN的值来判断用户是否登陆。这是基于cookie传输sessionid，这个session则是由tomcat来实现。

对于多个应用服务器而言，如果用户登陆的请求是放在其中一个应用服务器里，也就是说iIS_LOGIN标识是放在那个应用服务器里的tomcat里，而创建订单的请求则是到了另一个应用服务器里，但此时那个应用服务器的tomcat的session无法找到IS_LOGIN标识符，因此造成用户没有登陆的现象而无法创建订单的问题。

**解决方案**

生成一个token凭证，将token和登陆用户存储在部署于数据库服务器的redis里。当我们判断用户是否登陆时，查询redis即可。



## 数据库操作频繁

用一张图来说明流程：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb330e3d88f441093c2dbd6fe56c811~tplv-k3u1fbpfcp-zoom-1.image" style="zoom: 67%;" />

我们发现交易操作对总共会对数据库执行6次IO操作，并且我们对数据库的减库存操作decreaseStock是有一个行锁等待时间

```java
ItemModel itemModel = itemService.getItemById(itemId);	//从商品表中获取商品信息

UserModel userModel = userService.getUserById(userId);	//用户表中获取用户信息

boolean result = itemService.decreaseStock(itemId,amount);	//在商品库存表中减少库存量

orderDOMapper.insertSelective(orderDO);		//在订单表中添加订单信息

itemService.increaseSales(itemId,amount);	//在商品表中增加销量
```

**如何优化**

（1）对于第一，二条操作，也就是从数据表中获取商品和用户信息。我们可以优化成从redis里取，如下代码所示：

```java
//ItemServiceImpl

  @Override
    public ItemModel getItemByIdInCache(Integer id) {
        ItemModel itemModel = (ItemModel)redisTemplate.opsForValue().get("item_validate_" + id);
        if(itemModel == null) {
            itemModel = this.getItemById(id);
            redisTemplate.opsForValue().set("item_validate_"+id, itemModel);
            redisTemplate.expire("item_validate_"+id, 10, TimeUnit.MINUTES);
        }
        return itemModel;
    }

//UserServiceImpl
    @Override
    public UserModel getuserByIdInCache(Integer id) {
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get("user_validate_"+id);
        if(userModel == null) {
            userModel = this.getUserById(id);
            redisTemplate.opsForValue().set("user_validate_"+id, userModel);
            redisTemplate.expire("user_validate_"+id, 10, TimeUnit.MINUTES);
        }
        return userModel;
    }
```

然后修改获取商品信息和用户信息的方法：

```java
ItemModel itemModel = itemService.getItemByIdInCache(itemId);
UserModel userModel = userService.getuserByIdInCache(userId);
```

（2）在第三条操作，原本的操作逻辑是直接在商品表里减掉库存，我们同样可以修改为在redis里操作：在商品活动发布的同时，我们将活动商品的库存存进redis里，当对活动商品的库存执行减操作时，我们是在redis记录的库存里执行减操作而非在数据库里。

首先我们定义一个发布活动方法：该方法首先获取url传来的商品id，获取到对应的商品信息类后，将商品id，商品库存作为键值对存进redis里。

```java
//ItemController

    @RequestMapping(value = "/publishpromo",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType publishPromo(@RequestParam(name = "id")Integer id){
            promoService.publishPromo(id);
            return CommonReturnType.create(null);
    }

//PromoService
    public void publishPromo(Integer promoId) {
        PromoDO promoDO = promoDOMapper.selectByPrimaryKey(promoId);
        if(promoDO.getItemId() == null || promoDO.getItemId().intValue() == 0) {
            return;
        }
        /*
            假设此时读出来的商品数量是10件，存进redis时也是10件。
            这段时间内商品可能会被售卖，因此我们无法区分活动商品有多少，非活动商品有多少
            我们可以在活动开始时上架商品，活动尚未开始则商品是下架状态。从而解决区分数量的问题
            本项目是秒杀商品，默认商品数量是不会发生变化
        */
        ItemModel itemModel = itemService.getItemById(promoDO.getItemId());
        redisTemplate.opsForValue().set("promo_item_stock_"+itemModel.getId(), itemModel.getStock());

    }
```

这种做法存在一个问题：数据库的库存记录与redis的库存记录完全不一致。因此我们需要使用到异步消息中间件，常见的消息中间件有RabbitMQ，Kafka等。它负责将异步扣减的消息同步给消息的consumer端，并由消息的consunmer端完成数据库扣减的操作。

> 之后的改进请转至Rocketmq一栏的使用章节。



## 流量削峰

所谓的秒杀是指第一秒涌入的流量问题，我们需要将这第一秒的流量峰值平滑到之后的时间段里。因此便有了流量削峰的技术。

**秒杀令牌**

在前面的设计中，秒杀接口就是一个公网的url地址，即order/createorder。如果用户知道自己登陆所需的token，promoId和itemId，那么用户就可以通过一段脚本不断发送http请求到该接口，从而达到快速抢购多个秒杀商品的目的。

因此我们需要设置一个`UUID.Random()`生成的秒杀令牌，在用户下单前检查用户对应的令牌才可让其下单。

**秒杀大闸**

在活动一开始就会生成秒杀令牌，我们需要限制秒杀令牌的生成数量。此处我们限制发放的令牌数量最多是活动商品库存的5倍。

```java
 redisTemplate.opsForValue().set("promo_door_count_"+promoId, itemModel.getStock().intValue()*5);
```

在生成秒杀令牌前，需要检查秒杀令牌的可用量是否为0

```java
        //将redis内秒杀大闸减1
        long res = redisTemplate.opsForValue().increment("promo_door_count_"+itemModel.getId(), -1);
        if(res < 0) {
            return null;
        }
```

**队列泄洪**

设置令牌及数量限制并不能解决流量涌入问题，这是因为当前我们假设的活动商品库存量还很少，如果一个火爆商品的库存量很多（比如十万多个），那么就会有上万的tps涌入进来。因此在多库存，多商品的情况下，发放令牌数量对系统的保护能力很弱。

队列泄洪技术的原理在于限制一定的线程数去执行创建订单任务，多余的线程排队执行。

```java
//OrderController

private ExecutorService executorService;

    @PostConstruct
    public void init() {
        executorService = Executors.newFixedThreadPool(20);
    }
	
  //封装下单请求
    @RequestMapping(value = "/createorder",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType createOrder(@RequestParam(name="itemId")Integer itemId,
                                        @RequestParam(name="amount")Integer amount,
                                        @RequestParam(name="promoId",required = false)Integer promoId,
                                        @RequestParam(name="promoToken",required = false)String  promoToken) throws BusinessException {	
     //省略部分...   
        
	  //交由线程池创建的线程来初始化库存流水并发送减库存事务消息
        //在一台服务器上，同一时间内只有20个用户请求来下单，其他请求需要排队
        Future<Object> future =  executorService.submit(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                //初始化库存流水，并获取其状态
                String stockLogId = itemService.initStockLog(itemId, amount);

                //完成下单事务消息机制
                if(!mqProducer.transactionAsyncReduceStock(userModel.getId(), promoId, itemId,  amount, stockLogId)) {
                    throw new BusinessException(EmBusinessError.UNKNOWN_ERROR, "下单失败");
                }
                return null;
            }
        });
        try {
            future.get();
        } catch (InterruptedException e) {
            throw new BusinessException(EmBusinessError.UNKNOWN_ERROR);
        } catch (ExecutionException e) {
            throw new BusinessException(EmBusinessError.UNKNOWN_ERROR);
        }
        return CommonReturnType.create(null);
    }
```



## 防刷限流

在前面我们主要讲述了流量削峰的技术，它的目的在于缓解秒杀活动开始的第一秒内的流量峰值。而本章我们主要是防刷限流的操作。

- 限流是对系统的出入流量进行控制，防止大流量出入，导致资源不足，系统不稳定
- 防刷主要是为了防止黄牛流量。

**验证码**

当用户点击下单按钮后，会显示验证码并要求用户输入。

```java
//验证码
public class CodeUtil {
    private static int width = 90;      //图片的width,单位是像素
    private static int height = 20;     //图片的height
    private static int codeCount = 4;     //图片的验证码的个数
    private static int xx = 15;     //验证码左边的起始点
    private static int fontHeight = 18;     //验证码字体大小
    private static int codeY = 16;     //
    private static char[] codeSequence = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
                                            '0','1','2','3','4','5','6','7','8','9'};     //验证码

    //生成验证码及图片
    public static Map<String, Object> generateCOdeAndPic() {
        BufferedImage buffImg = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);
        Graphics graphics = buffImg.getGraphics();
        Random random = new Random();

        graphics.setColor(Color.WHITE);
        graphics.fillRect(0, 0, width, height);

        //设置字体
        Font font = new Font("Fixedsys", Font.BOLD, fontHeight);
        graphics.setFont(font);

        //画边框
        graphics.setColor(Color.BLACK);
        graphics.drawRect(0, 0, width-1, height-1);

        //随机产生40条干扰线，这样图像中的验证码不易被其他程序探测到
        graphics.setColor(Color.BLACK);
        for(int i=0; i<30; i++) {
            int x = random.nextInt(width);
            int y = random.nextInt(height);
            int xl = random.nextInt(12);
            int yl = random.nextInt(12);
            graphics.drawLine(x, y, x+xl, y+yl);
        }
        //存储随机产生的验证码
        StringBuffer randomCode = new StringBuffer();
        int red=0, green=0, blue=0;

        //产生codeCount
        for(int i=0; i<codeCount; i++) {
            String code = String.valueOf(codeSequence[random.nextInt(36)]);
            //产生随机的颜色分量构造颜色值，这样输出的每个数字的颜色值都不同
            red = random.nextInt(255);
            green = random.nextInt(255);
            blue = random.nextInt(255);

            //用随机产生的颜色将验证码绘制到图像中
            graphics.setColor(new Color(red, green, blue));
            graphics.drawString(code, (i+1)*xx, codeY);
            //将产生的四个随机数组合在一起
            randomCode.append(code);
        }

        Map<String, Object> map = new HashMap<>();
        map.put("code", randomCode);
        map.put("codePic", buffImg);

        return map;
    }
}
```



**令牌桶**

Google开源工具包Guava提供了限流工具类RateLimiter，它支持两种获取permits接口：一种是如果拿不到立刻返回false；一种会阻塞等待一段时间看能不能拿到。此处我们使用的是后者。

```java
    private RateLimiter orderCreateRateLimiter;

    private ExecutorService executorService;

    @PostConstruct
    public void init() {
        executorService = Executors.newFixedThreadPool(20);
        //每秒最多处理300个请求
        orderCreateRateLimiter = RateLimiter.create(300);
    }

    //封装下单请求
    @RequestMapping(value = "/createorder",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType createOrder(@RequestParam(name="itemId")Integer itemId,
                                        @RequestParam(name="amount")Integer amount,
                                        @RequestParam(name="promoId",required = false)Integer promoId,
                                        @RequestParam(name="promoToken",required = false)String  promoToken) throws BusinessException {

        if(!orderCreateRateLimiter.tryAcquire()) {
            throw new BusinessException(EmBusinessError.RATELIMIT);
        }
        //....
    }
```





# 初识redis

## 配置

**修改redis配置文件**

在将redis下载到数据库服务器后，我们首先修改配置文件。

我们可以将redis监听在内网ip地址里，这样应用服务器里的程序所绑定的redis.host就是内网ip地址。

进入redis/redis.conf文件，它默认绑定在0.0.0.0，也就是所有能连接到数据库服务器Ip（无论是外网ip还是内网ip）都可以使用这个redis：

```
bind 加上数据库服务器的私网ip。
#注释掉里面的bind 127.0.0.1语句
protected-mode no #修改保护模式
```

然后执行` src/redis-server ./redis.conf &`指定配置文件并在后台启动。



**存储session到redis里**

导入依赖：

```xml
        <!--redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--session-->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
            <version>2.2.0.RELEASE</version>
        </dependency>
```

springboot会将自己对session的一套管理方式存储在redis里。

在项目的主配置文件里：

```
#redis    
spring.redis.host=127.0.0.1
spring.redis.port=6379
    #使用第10个database
spring.redis.database=10

#设置jedis连接池
spring.redis.jedis.pool.max-active=50
spring.redis.jedis.pool.min-idle=20
```

> **如果某个类涉及到了redis的操作，则这个类及其属性类必须要序列化：implements Serializable 。**比如此处的UserModel

执行`redis-server`开启redis服务后，执行项目，并在执行`redis-cli`开启客户端，执行如下命令：

```
select 10
keys *
```

即可发现存储session的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30e9abc9410e4d0ca7decdc770234d68~tplv-k3u1fbpfcp-zoom-1.image)



## 基于token的分布式会话实现

**概念**

在前面我们是基于cookie传输sessionid

```java
//登陆后将标识符放入session里  
this.httpServletRequest.getSession().setAttribute("IS_LOGIN",true);
 this.httpServletRequest.getSession().setAttribute("LOGIN_USER",userModel);

//创建订单时根据session验证是否登陆
        Boolean isLogin = (Boolean) httpServletRequest.getSession().getAttribute("IS_LOGIN");
        if(isLogin == null || !isLogin.booleanValue()){
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }

```

对于一个企业应用而言，我们不光需要支持html页面，可能还需要支持一些移动设备，微信小程序，安卓，ios等。这些操作不一定支持cookie传输sessionid，并且网络的cookie规则可能会被改变。这些都是开发人员无法保证的，因此我们都是采用基于token传输类似sessionid的方式来完成类似的操作。

**如何实现**

首先我们在登陆方法login下创建一个token并放入redis里

```java
@Autowired
private RedisTemplate redisTemplate;


    @RequestMapping(value = "/login",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType login(@RequestParam(name="telphone")String telphone,
                                  @RequestParam(name="password")String password) throws BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {
        //...
		//登陆凭证token, UUID
        String uuidToken = UUID.randomUUID().toString();
        uuidToken = uuidToken.replace("-","");
        //token和用户信息作为键值对
        redisTemplate.opsForValue().set(uuidToken, userModel);
        redisTemplate.expire(uuidToken, 1, TimeUnit.HOURS); //超时时间
		//...
 		return CommonReturnType.create(null);
    }
/*
uuid：89814521-33e0-40fd-8c33-74b4184f3cf9
redis存储的键值对："\xac\xed\x00\x05t\x00$58dbc259-bbf6-404d-8df9-52492dc4d8ad"
*/
```

在登陆页面login.html中取出data里的token

```js
			success:function(data){
					if(data.status == "success"){
						alert("登陆成功");
						var tooken = data.data;				//取出
						window.localStorage["token"] = tooken;
						window.location.href="listitem.html";
					}else{
						alert("登陆失败，原因为"+data.data.errMsg);
					}
				},
				error:function(data){
					alert("登陆失败，原因为"+data.responseText);
				}
			});
```

在商品页面getitem.html里，取出token并在动态请求url里放入url中。

```js
jQuery(document).ready(function(){
		$("#createorder").on("click",function(){
		var token = window.localStorage["token"];
		if(token == null) {
			alert("你还没有登陆，无法下单");
			window.location.href="login.html";
			return false;
		}
			$.ajax({
				type:"POST",
				contentType:"application/x-www-form-urlencoded",
				url:"http://"+g_host+"/order/createorder?token=" + token,		//在url传入token
				data:{
					"itemId":g_itemVO.id,
					"amount":1,
					"promoId":g_itemVO.promoId
				},
```

在订单方法OrderControler/createOrder下获取页面传进来的参数token，并作为是否登陆的判断标准。

```java
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }
```



## redis缓存商品

在查询商品信息时，我们可以先去redis里查询：如果没有再从数据库里查询，并将(item_id，商品完整信息对象)存进redis里。

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd03a3b9ffa41d3ad16415bac1bf542~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

**实现代码**

在获取商品方法getItem中使用redis：

```java
//ItemController

    @Autowired
    private RedisTemplate redisTemplate;

    @RequestMapping(value = "/get",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType getItem(@RequestParam(name = "id")Integer id){

        ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get("item_"+id);
        if(itemModel == null) {
            itemModel = itemService.getItemById(id);
            redisTemplate.opsForValue().set("item_"+id, itemModel);
            redisTemplate.expire("item_"+id, 10, TimeUnit.MINUTES);
        }

        ItemVO itemVO = convertVOFromModel(itemModel);

        return CommonReturnType.create(itemVO);

    }
```

输入地址http://localhost:8090/item/get?id=6查看商品信息，在redis里即可看到存储的内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc20e3664c34940b7799195c8c16021~tplv-k3u1fbpfcp-zoom-1.image)

我们可以自定义键和值的存储方式，使其看上去能了解存储的信息。

首先我们要定义ItemModel里的属性startTime序列化格式：

```java
package com.imooc.miaoshaproject.serializer;

import java.io.IOException;

public class JodaDateTimeJsonSerializer extends JsonSerializer<DateTime> {
    @Override
    public void serialize(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeString(dateTime.toString("yyyy-MM-dd HH:mm:ss"));
    }
}

```

反序列化格式：

```java
public class JodaDateTimeJsonDeserrializer extends JsonDeserializer<DateTime> {
    //将dataString按照格式转成DateTime
    @Override
    public DateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        String dateString = jsonParser.readValueAs(String.class);
        DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");

        return DateTime.parse(dateString,formatter);
    }

}
```

自定义RedisTemplate配置类，将自定义的序列化方式注册进去。

```java
@Component
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
public class RedisConfig {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //key的序列化：String的序列化方式
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringRedisSerializer);

        //value的序列化：Json的序列化方式
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper objectMapper = new ObjectMapper();
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(DateTime.class, new JodaDateTimeJsonSerializer());
        simpleModule.addDeserializer(DateTime.class, new JodaDateTimeJsonDeserrializer());
        //除final外的的属性信息都需要被序列化和反序列化。
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        objectMapper.registerModule(simpleModule);      //注册自定义的序列化和反序列模块

        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);


        return redisTemplate;
    }
}

```

结果如下图所示：

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5af882251e4d1e8c967b4ce70881e3~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:200%;" />

> redis命令 flushall 可以清除全部key-value

### Guava缓存

此外我们还可以使用com.google.common.cache作为一道新的商品缓存，Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。因此对于一些情况可以考虑使用Guava Cache：

1. 愿意消耗一些内存空间来提升速度。
2. 预料到某些键会被多次查询。
3. 缓存中存放的数据总量不会超出内存容量。

我们可以将程序频繁用到的少量数据存储到Guava Cache中，以改善程序性能。

**程序代码**

首先引入依赖：

```xml
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>18.0</version>
    </dependency>
```

定义一个封装缓存操作的接口：

```java
package com.imooc.miaoshaproject.service;

//封装本地缓存操作类
public interface CacheService {

    void setCommonCache(String key, Object value);

    Object getCommonCache(String key);
}
```

实现类：

```java
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

@Service
public class CacheServiceImpl implements CacheService {

    private Cache<String, Object> commonCache = null;
    //spring bean 会在bean加载时优先执行该注解方法
    @PostConstruct
    public void init() {
        //缓存容器的初始容量为10，缓存最多存储100个key，若超过则按照lru策略移除缓存项
        //expireAfterWrite的过期时间是相对于被写进的时间,expireAfterAccess的过期时间是相对于被访问的时间
        commonCache = CacheBuilder.newBuilder().initialCapacity(10)
                .maximumSize(100).expireAfterWrite(60, TimeUnit.SECONDS).build();
    }

    @Override
    public void setCommonCache(String key, Object value) {  commonCache.put(key, value); }

    @Override
    public Object getCommonCache(String key) {  return commonCache.getIfPresent(key); }
}
```

在商品获取的方法中通过缓存操作类来实现本地缓存：

```java
//ItemController

	@Autowired
    private CacheService cacheService;
    
    @RequestMapping(value = "/get",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType getItem(@RequestParam(name = "id")Integer id){
        ItemModel itemModel = null;
        //查看本地缓存
        itemModel = (ItemModel)cacheService.getCommonCache("item_"+id);

        if(itemModel == null) {
            itemModel = (ItemModel) redisTemplate.opsForValue().get("item_"+id);    //查看redis
            if(itemModel == null) {
                itemModel = itemService.getItemById(id);
                redisTemplate.opsForValue().set("item_" + id, itemModel);
                redisTemplate.expire("item_" + id, 10, TimeUnit.MINUTES);

            }
            cacheService.setCommonCache("item_" + id, itemModel);
        }

        ItemVO itemVO = convertVOFromModel(itemModel);

        return CommonReturnType.create(itemVO);

    }
```







# 初识Nginx

## 安装

**OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。**

在[OpenResty官网](https://openresty.org/cn/download.html)下载对应.tar.gz文件后，使用命令：

```
tar -zxvf
```

解压后，根据[安装教程](https://openresty.org/cn/installation.html)进入OpenResty，执行如下命令安装开发库

```
apt-get install libpcre3-dev \
libssl-dev perl make build-essential curl
```

然后接连输入如下命令以配置，编译，安装。

```
apt-get update
apt-get install libpcre3-dev
apt-get install openssl
apt-get install zlib1g-dev
./configure
make
make install
```

它会自动安装在/usr/local/openresty下。

进入/usr/local/openresty/nginx，输入命令开启nginx。

```
sbin/nginx -c conf/nginx.conf
```

如果之前已经开启了nginx，则重启nginx即可

```
sbin/nginx -s reload
```



他会默认启动在80端口。在浏览器里输入服务器IP地址即可看见nginx的欢迎页面。

> 关于nginx的一些配置，你可以在/usr/local/openresty/nginx/conf/nginx.conf下找到。



## 反向代理

**什么是正向代理**

正向代理是一个位于客户端和目标服务器之间的代理服务器。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。

正向代理需要主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回。服务端不知道真实的客户端是谁，请求的服务都被代理服务器代替来请求。

**什么是反向代理**

反向代理隐藏了真实的服务端：代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。两者的区别在于代理的对象不同：一个是客户端，一个是服务端。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c9b5e4bd43e42929d9fb4d4573a1c9e~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />

nginx支持配置反向代理，通过反向代理实现网站的负载均衡。

**使用**

按照下图中的扩展，假设nginx部署在maioshaserver服务器下。当H5请求是一个static页面时（即静态资源请求），我们访问resources路径下的页面；当H5请求是ajax请求时，则会认定为动态请求被nginx反向代理。如下所示：

- miaoshaserver/resources/getotp.html    
- miaoshaserver/item/get?id=3

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dabf4cf1925242baba60df438fcb99cf~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />



**配置动静分离服务器**

我们将访问的所有页面放在resources文件夹下，并将resources文件夹放在nginx的html文件夹里。

执行`vim /usr/local/openresty/nginx/conf/nginx.conf`进入文本编辑器，然后按i进入编辑模式，并按下图修改页面定向：

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f23a8446464c44a2b2d7ca4bb379ff~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

```
 #gzip  on;
 	#(1)
    upstream backend_server{					
        server 120.25.205.138  weight=1;		
        #server 第二个放置jar包的应用服务器的内网ip地址  weight=1;		
        										
    }


    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;
		#(2)
		
        location /resources/  {
        	add_header Access-Control-Allow-Origin *;  #跨域问题
            alias /usr/local/openresty/nginx/html/resources/;
            index  index.html index.htm;
        }
        
		
		#(3)
       location / {
         add_header Access-Control-Allow-Origin *;	#跨域问题
         add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';

         add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

         if ($request_method = 'OPTIONS') {
                return 204;
          }
     
         proxy_pass http://backend_server;					
         proxy_set_header Host $http_host:$proxy_port;		
         proxy_set_header X-Real-IP $remote_addr;	#
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       }
```

下面解释以下上述三点的设置概念：

（1）后端服务器集群backend_server。这里面是部署jar的各个服务器ip地址，此处本应是私网地址，这样速度会快点。但我这里是公网地址

weight表示权重，如果两个权重为1，则表示有一半的请求轮询到其中一个。

（2）当localtion的规则命中了/resources/目录后，alias字段将/resources/替换为/usr/local/openresty/nginx/html/resources/。

（3）除了对resources下的请求，我们都当作动态资源请求。	

- proxy_pass http：nginx将请求反向代理到http://backend_server上
- Host $http_host:$proxy_port：拼接上对应的域名和端口
- 设置后端服务器拿到的真正ip地址X-Real-IP是远端客户端地址，若不设置则它拿到的是nginx地址
- proxy_add_x_forwarded_for变量包含客户端请求头中的"X-Forwarded-For"。一般情况下，当用户请求经过内容分发网络CDN到达nginx时，下X-Forwarded-For头信息为客户端IP，则此处我们又设置了一次，X-Forwarded-For的内容就变成 ”客户端IP,Nginx负载均衡服务器IP“；但如果从CDN过来的请求没有设置X-Forwarded-For头（通常不会发生），而在这里我们又设置了 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  那么X-Forwarded-For的信息是CDN的IP，此时后端程序无法获取用户IP地址。

按Esc然后`:wq`退出编后，执行 `sbin/nginx -s reload `重启nginx。

总结来说：当我们向nginx服务器miaoshaserver发起请求时，比如说miaoshaserver/resources/getotp.html ，它将会返回放置html/resources下的对应页面。我们在页面填写完信息后，getotp将向miaoshaserver发起ajax请求，nginx服务器会将这个ajax请求代理到两个应用服务器（私网ip）中的一个。



**查看日志**

我们可以在项目的配置文件里开启tomcat access log来验证反向代理是否成功。

进入项目文件夹miaosha下的外挂配置文件application.properties，添加：

```
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.directory=/usr/local/java_project/miaosha/tomcat
server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b %D

#   %h表示远端host地址（远端IP地址）
#   %l 默认返回-
#   %u 表示远端主机user
#   %t 表示处理时间
#   %r 打印请求的方法/url
#   %s HTTP返回状态码
#   %b 表示请求response的大小
#   %D 表示处理请求时长
```

在miaosha下新建文件夹tomcat，授权所有权限`sudo chmod 777 tomcat/`，这个文件夹放置nginx代理请求的日志文件地址。

在地址栏发起请求：miaoshaserver/item/get?id=3，会发现tomcat文件夹多出一个以时间命名的日志文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3ead9baf46431c94c1b9253c4fddf9~tplv-k3u1fbpfcp-zoom-1.image)





## 内存字典

shared dic是基于nginx内存一个缓存，它对所有worker进程可见。它类似于Gruva cache的key-value的数据结构，同时它可以指定最近最少未使用lru的淘汰规则。因此我们同样可以把商品信息存进nginx里。当有对商品的查询请求进入nginx时，nginx首先查询字典里是否有对应的数据，若有则返回，否则向应用服务器发起请求。

**操作步骤**

首先在`openresty/conf/nginx.conf`下定义字典和请求的规则：

```
#指定内存字典的大小
lua_shared_dict my_cache 128m;

    server {
       #省略...
        
        #将luaitem/get请求代理到指定的Lua脚本
        location /luaitem/get {
        
            default_type "application/json";
            content_by_lua_file ../lua/itemsharedic.lua;
        }
```

在`openresty下创建存放lua脚本的文件夹lua`，然后在文件夹里创建一个itemsharedic.lua的脚本：

```lua
function get_from_cache(key)
         local cache_ngx = ngx.shared.my_cache
         local value = cache_ngx:get(key)
         return value
end      

function set_to_cache(key,value,exptime)
        if not exptime then
                exptime = 0
        end     
        local cache_ngx = ngx.shared.my_cache
        local succ,err,forcible = cache_ngx:set(key,value,exptime)
        return succ
end     

local args = ngx.req.get_uri_args()
local id = args["id"]
local item_model = get_from_cache("item_"..id)
if item_model == nil then
        local resp = ngx.location.capture("/item/get?id="..id)
        item_model = resp.body
        set_to_cache("item_"..id,item_model,1*60)
end     
ngx.say(item_model)


```

解释一下这个脚本：从请求的uri（ngx.req.get_uri）中取出参数args，并提取出id字段。尝试着根据id从之前定义的内存字典my_cache取出对应的itemModel：

- 若不存在，则发起 /item/get?id 请求，并从响应中取出itemModel，放入内存字典里。
- 然后ngx.say(itemModel)



## redis操作

同样我们可以在nginx里操作redis，在`openresty/lualib/resty`里，存储了操作redis的lua脚本redis.lua。因此我们可以如操作内存字典一样去操作redis。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd4be18e02e842c49b2d2b43d379587f~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

**操作步骤**

在`openresty/lua`创建itemredis.lua

```
local args = ngx.req.get_uri_args()
local id = args["id"]
local redis = require "resty.redis"
local cache = redis:new()
local ok, err = cache:connect("172.18.190.68", 6379)
local item_model = cache:get("item_"..id)

if item_model == ngx.null or item_model == nil then
        local resp = ngx.location.capture("/item/get?id="..id)
        item_model = resp.body
end

ngx.say(item_model)
```

在将前面的`openresty/conf/nginx.conf`下修改指定的lua脚本为itemredis.lua

```
content_by_lua_file ../lua/itemsharedic.lua
```



# Rocketmq

## 安装

~~参考[官方文档](https://rocketmq.apache.org/docs/quick-start/)。~~

> ps：官网文档贼坑人，害我找错误找的贼久。如果遇到如下的错误，参考如下博客
>
> [No route info of this topic以及org.apache.rocketmq.remoting.exception.RemotingTooMuch异常](https://blog.csdn.net/qq_35580701/article/details/107055506)



（1）在解压完rocketmq后，进入文件，首先修改一下大小：

```
vim bin/mqbroker.xml
```

来修改mqbroker

```
-XX:NewSize>128M</-XX:NewSize>
<-XX:MaxNewSize>128M</-XX:MaxNewSize>
<-XX:PermSize>64M</-XX:PermSize>
<-XX:MaxPermSize>64M</-XX:MaxPermSize>
```

执行

```
vim bin/runbroker.sh
```

修改java的启动配置：

```
JAVA_OPT="${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn512m"
```

**（2）开启namesrv和mqbroker：**

```
nohup sh bin/mqnamesrv -n 120.25.205.138:9876 &

nohup sh bin/mqbroker -n 120.25.205.138:9876 -c conf/broker.conf autoCreateTopicEnable=true &
```

你可以通过如下命令查看namesrv和mqbroker的日志

```
tail -f ~/logs/rocketmqlogs/namesrv.log
tail -f ~/logs/rocketmqlogs/broker.log
```

（3）指定环境变量：` export NAMESRV_ADDR=localhost:9876`。

**生产和消费示例**

投放服务：`sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer`

消费服务：`sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer`

目前我们使用的topic是rocketmq自带的TopicTest，我们也可以自定义topic。

进入bin文件，执行如下命令创建一个名为stock的topic：

```
./mqadmin updateTopic -n localhost:9876 -t stock -c DefaultCluster
```



## 使用

> 本节继续之前提到的数据库操作频繁的问题。

在主配置文件中配置：

```
mq.nameserver.addr=120.25.205.138:9876	#放置RocketMQ服务器公网ip
mq.topicname=stock
```

导入依赖：

```xml
  <dependency>
        <groupId>org.apache.rocketmq</groupId>
        <artifactId>rocketmq-client</artifactId>
        <version>4.3.0</version>
    </dependency>
```



（1）定义消费类

```java
@Component
public class MqConsumer {

    private DefaultMQPushConsumer consumer;

    @Value("${mq.nameserver.addr}")
    private String nameAddr;

    @Value("${mq.topicname}")
    private String topicName;

    @Autowired
    private ItemStockDOMapper itemStockDOMapper;

    @PostConstruct
    public void init() throws MQClientException {
        //consumergroup会将consumer绑定成一个组，但producer_group对于rocketmq没有意义
        consumer = new DefaultMQPushConsumer("stock_consumer_group");
        consumer.setNamesrvAddr(nameAddr);
        //订阅topicName的所有消息
        consumer.subscribe(topicName, "*");
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            //CONSUME_SUCCESS表示消息已被消费，因此将数据同步到数据库里。
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                Message msg = list.get(0);
                String jsonStr = new String(msg.getBody());
                Map<String, Object> map = JSON.parseObject(jsonStr, Map.class);

                Integer itemId = (Integer)map.get("itemId");
                Integer amount = (Integer)map.get("amount");

                itemStockDOMapper.decreaseStock(itemId, amount);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        //开启
        consumer.start();
    }

}
```



（2）定义生产类

```java
@Component
public class MqProducer {
    private DefaultMQProducer producer;

    @Value("${mq.nameserver.addr}")
    private String nameAddr;

    @Value("${mq.topicname}")
    private String topicName;

    @PostConstruct
    public void init() throws MQClientException {
        //consumergroup会将consumer绑定成一个组，但producer_group对于rocketmq没有意义，因此名字随便取
        producer = new DefaultMQProducer("producer_group");
        producer.setNamesrvAddr(nameAddr);

        producer.start();

    }
    public boolean asyncReduceStock(Integer itemId, Integer amount) {
        Map<String, Object> bodyMap = new HashMap<>();

        bodyMap.put("itemId", itemId);
        bodyMap.put("amount", amount);
        Message message = new Message(topicName, "increase",
                JSON.toJSON(bodyMap).toString().getBytes(Charset.forName("UTF-8")));

        try {
            producer.send(message);
        } catch (MQClientException e) {
            e.printStackTrace();
            return false;
        } catch (InterruptedException e) {
            e.printStackTrace();
            return false;
        } catch (RemotingException e) {
            e.printStackTrace();
            return false;
        } catch (MQBrokerException e) {
            e.printStackTrace();
            return false;
        }
        Iterator ie = new ArrayList<>().iterator();
        return true;
    }
}
```

（3）业务层上的减库存操作

```java
//ItemServiceImpl

	@Override
    @Transactional
    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {
        //首先在redis里减库存
        long  result = redisTemplate.opsForValue().increment("promo_item_stock_"+itemId, amount.intValue()*-1);
//        int affectedRow =  itemStockDOMapper.decreaseStock(itemId,amount);
        if(result >= 0){    //如果更新库存成功
            //发送异步消息给对应库存的异步回调，然后再异步回调内扣减数据库的库存
            boolean mqResult = mqProducer.asyncReduceStock(itemId, amount);
            if(!mqResult) {     //如果消息更新失败，则把redis记录的库存加回去
                redisTemplate.opsForValue().increment("promo_item_stock_"+itemId, amount.intValue());
                return  false;
            }
            return true;
        }else{
            //如果redis扣减库存失败
            redisTemplate.opsForValue().increment("promo_item_stock_"+itemId, amount.intValue());
            return false;
        }

    }
```



## 事务性消息

### 少卖情况

在业务层OrderServiceImpl的createOrder方法里，首先会对redis里的活动商品库存执行减操作，然后将减库存的消息发送出去了，并且消费端consumer已经扣减了。但是在第三步的订单入库操作中出现异常，也就是说用户下单失败，那么这个事务方法createOrder会回滚。

```java
    @Override
    @Transactional
    public OrderModel createOrder(Integer userId, Integer itemId, Integer promoId, Integer amount) throws BusinessException {
     	//1.检查下单状态...

        //2.落单减库存
        boolean result = itemService.decreaseStock(itemId,amount);
        if(!result){
            throw new BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);
        }
        //3.订单入库
        OrderModel orderModel = new OrderModel();
        //...
        OrderDO orderDO = convertFromOrderModel(orderModel);
        orderDOMapper.insertSelective(orderDO);
    }
```

但是这redis里的库存就白白损失掉了，也就是发生了少卖的情况

> 少卖：商家发现库存莫名其妙的变少了，但又找不到对应的订单，仓库里就会积压一部分的货物。

出现这种情况的原因在于`decreaseStock`方法在发送异步消息之前，无法确认第2步之后的操作是否成功。因此我们rocketMQ自带的`transactionMQProducer`来发送事务型消息



**可能出现的一些问题**

（1）redis不可用时如何处理？

如果redis不可用，我们可以回源数据库。但此时所有异步消息的同步状态是否都完成？举例说明：redis里的库存减掉5件，但是这5件库存流水消息并没有完全投放出去，导致对应的库存扣减操作没有做完。那么数据库的库存会比redis的库存多。如果重复扣减的话就会产生超卖。

（2）扣减流水错误如何处理

**如何处理**

争对上述问题，我们需要根据不同的业务场景来确定不同的策略。比如说：我们确定一个设计原则：宁可少卖，不可多卖。因为如果少卖的话，最坏情况也就是商家的货无法销售，但如果是超卖的情况，那么在最坏情况下就是商家无法发货，需要自己贴钱这个超卖的货。但也有些电商公司是追求极致的销售量，只要用户可以买，即便库存已经卖爆了，它们也有一些渠道能能够很快的补货，那么它们的设计原则就是相反的：宁可多卖，不可少卖。

如果设计原则是前者，那么上述问题的解决方案是：

（1）redis的数据值可以比实际数据库的数据值少。此时我们不能回源到数据库，因为此时无法确定数据库的状态是否正常。此时我们宁愿取消掉用户的操作，以便保证redis操作的一致性和高可用性。

（2）超时释放。

假设在创建订单的方法中一直没有返回，或者程序死掉了，也就是说，它无法走到下面返回状态的程序。

```java
  orderService.createOrder(userId, itemId, promoId, amount, stockLogId);
```

此时流水状态一直都是1，在`checkLocalTransaction`方法里就会一直返回UNKNOW状态。但此时redis里的库存已经扣减掉了，莫名奇妙的扣减了库存但程序因为卡死而无法创建订单。就算我们把它定义为失败，但redis里扣减的库存无法加回去。

因此在订单体系中需要设置一个超时释放的程序：当下单操作达到某一限定时间后，用户还无法收到是订单是成功还是失败状态，该程序需要将这个库存回滚释放掉，把redis里对应数量加回去。



### 流量削峰

**缺陷**

在前面的设计中，秒杀接口就是一个url地址，即order/createorder。如果用户知道自己登陆所需的token，promoId和itemId，那么用户就可以通过一段脚本不断发送http请求到该接口，从而达到快速抢购多个秒杀商品的目的。

因此我们需要设置一个类似token的秒杀令牌，并在用户下单前检查用户对应的令牌才可让其下单。



# 总结

## 登陆

（1）用户需要输入电话号码和密码来登陆，在检查完登陆信息是否正确后，通过` UUID.randomUUID()`生成一个登陆凭证uuidToken，将(uuidToken，用户信息类userModel)放入redis里，并设置有效时间。返回uuidToken给前端。

```java
//UserController

	@RequestMapping(value = "/login",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType login(@RequestParam(name="telphone")String telphone,
                                  @RequestParam(name="password")String password) throws BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {

        //入参校验
        if(org.apache.commons.lang3.StringUtils.isEmpty(telphone)||  StringUtils.isEmpty(password)){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
        }

        //用户登陆服务,用来校验用户登陆是否合法
        UserModel userModel = userService.validateLogin(telphone,this.EncodeByMd5(password));
        //将登陆凭证加入到用户登陆成功的session内

        //登陆凭证token, UUID
        String uuidToken = UUID.randomUUID().toString();
        uuidToken = uuidToken.replace("-","");
        //token和用户作为键值对
        redisTemplate.opsForValue().set(uuidToken, userModel);
        redisTemplate.expire(uuidToken, 1, TimeUnit.HOURS); //超时时间1小时


        return CommonReturnType.create(uuidToken);
    }
	//注册功能中保存进数据库的密码需要通过此方法加密，验证密码同样需要此方法来将输入的密码转为密文
    public String EncodeByMd5(String str) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        //确定计算方法
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        BASE64Encoder base64en = new BASE64Encoder();
        //加密字符串
        String newstr = base64en.encode(md5.digest(str.getBytes("utf-8")));
        return newstr;
    }

```

（2）login.html页面收到成功后，通过`window.localStorage["token"] = tooken;`保存登陆凭证token。

```javascript
	xhrFields:{withCredentials:true},
				success:function(data){
					if(data.status == "success"){
						alert("登陆成功");
						var tooken = data.data;
						window.localStorage["token"] = tooken;
						window.location.href="listitem.html";
					}else{
						alert("登陆失败，原因为"+data.data.errMsg);
					}
				},
				error:function(data){
					alert("登陆失败，原因为"+data.responseText);
				}
			});
```



## 发布活动

所谓的发布活动就是将商品id及库存量放进redis里，然后还要设置秒杀令牌的大闸放进redis里。

```java
// ItemController

    @RequestMapping(value = "/publishpromo",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType publishPromo(@RequestParam(name = "id")Integer id){
            promoService.publishPromo(id);
            return CommonReturnType.create(null);
    }

//PromoServiceImpl

    @Override
    public void publishPromo(Integer promoId) {
        PromoDO promoDO = promoDOMapper.selectByPrimaryKey(promoId);
        if(promoDO.getItemId() == null || promoDO.getItemId().intValue() == 0) {
            return;
        }
        /*
            假设此时读出来的商品数量是10件，存进redis时也是10件。
            这段时间内商品可能会被售卖，因此我们无法区分活动商品有多少，非活动商品有多少
            我们可以在活动开始时上架商品，活动尚未开始则商品是下架状态。从而解决区分数量的问题
            本项目是秒杀商品，默认商品数量是不会发生变化
        */
        ItemModel itemModel = itemService.getItemById(promoDO.getItemId());
        redisTemplate.opsForValue().set("promo_item_stock_"+itemModel.getId(), itemModel.getStock());
        ////大闸的限制数字设置在redis内，最多发放5倍库存量的令牌数量
        redisTemplate.opsForValue().set("promo_door_count_"+promoId, itemModel.getStock().intValue()*5);

    }
```



## 下单购物

（1）当用户在商品信息getItem页面点击下单按钮时，首先会从`window.localStorage["token"];`取出token，用来判断用户是否已登录，随后向`order/generateverifycod`接口发起ajax请求（请求中携带了token），以便在<img>标签里填充验证码图片。

```javascript
<!--
<div class="form-actions">
	<button class="btn blue" id="createorder" type="submit">
				下单
	</button>	
</div>
<div id="verifyDiv" style="display:node;" class="form-actions">
	<img src=""/>
		<input type="text" id="verifyContent" value="" />
		<button class="btn blue" id="verifyButton" type="submit">
				验证
	</button>	
</div>
->
    //点击下单按钮后，显示验证码
		$("#createorder").on("click",function(){
			var token = window.localStorage["token"];
			if(token == null) {
				alert("你还没有登陆，无法下单");
				window.location.href="login.html";
				return false;
			}
			//填充从order/generateverifycod方法里放入的验证码图片
			$("#verifyDiv img").attr("src", "http://"+g_host+"/order/generateverifycode?token="+token);
			$("#verifyDiv").show();
		});
           
```

（1-1）在`order/generateverifycod`方法：

- 根据请求传来的登陆凭证检查登陆状态和用户信息
- 生成验证码并放进redis里，然后将验证码图片写进响应的输出流response.getOutputStream()里。

```java
//OrderController

   //生成验证码
    @RequestMapping(value = "/generateverifycode",method = {RequestMethod.GET, RequestMethod.POST})
    @ResponseBody
    public void generateverifyCode(HttpServletResponse response) throws BusinessException, IOException {
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能生成验证码");
        }
        //获取用户的登陆信息
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get(token);
        if(userModel == null) {     //会话过期
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能生成验证码");
        }
        //获取验证码并放进redis
        Map<String, Object> map = CodeUtil.generateCOdeAndPic();
        redisTemplate.opsForValue().set("verity_code_"+userModel.getId(), map.get("code"));
        redisTemplate.expire("verity_code_"+userModel.getId(), 10, TimeUnit.MINUTES);


        ImageIO.write((RenderedImage)map.get("codePic"), "jpeg", response.getOutputStream());


        System.out.println("验证码值为：" + map.get("code"));
    }
```

（1-2）getItem页面填充完验证码，并等到输入完验证码点击验证按钮后，向`order/generatetoken`接口发起ajax请求，获取秒杀令牌

```javascript
	//输入完验证码后
	$("#verifyButton").on("click", function(){
			var token = window.localStorage["token"];
			$.ajax({
				type:"POST",
				contentType:"application/x-www-form-urlencoded",
                //获取秒杀令牌
				url:"http://"+g_host+"/order/generatetoken?token=" + token, 
				data:{
					"itemId":g_itemVO.id,
					"promoId":g_itemVO.promoId,
					"verifyCode":$("#verifyContent").val()
				},
				xhrFields:{withCredentials:true},
				success:function(data){
					if(data.status == "success"){
						//发起创建订单的请求，详情参见（3）
					}else{
						alert("获取令牌失败，原因为"+data.data.errMsg);
						if(data.data.errCode == 20003){
							window.location.href="login.html";
						}
					}
				},
				error:function(data){
					alert("获取令牌失败，原因为"+data.responseText);
				}
			});	
	});
```

（2）`order/generatetoken()`接口接收ajax请求后：

- 在redis里取出token对应的用户信息类UserModel，检查是否登陆
- 比较redis里的验证码和请求里带来的验证码是否相同，若不是则报错。
- 调用`promoService.generateSecondKillToken`获取秒杀令牌，若获取失败则抛出异常，否则将令牌返回给前端。

```java
//OrderController

@RequestMapping(value = "/generatetoken",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType generateToken(@RequestParam(name="itemId")Integer itemId,
                                        @RequestParam(name="promoId")Integer promoId,
                                        @RequestParam(name ="verifyCode")String verifyCode) throws BusinessException {

        //1获取用户的登陆信息
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }

        
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get(token);
        if(userModel == null) {     //会话过期
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }
        //2比较redis里的验证码和请求里输入的验证码是否相等（忽略大小写）
        String inRedisVerifyCode = (String)redisTemplate.opsForValue().get("verity_code_"+userModel.getId());
        if(StringUtils.isEmpty(inRedisVerifyCode)) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"请求非法");
        }
        if(!inRedisVerifyCode.equalsIgnoreCase(verifyCode)) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"请求非法，验证码错误");
        }


        //3获取令牌
        String promoToken = promoService.generateSecondKillToken(promoId, itemId, userModel.getId());
        if(promoToken == null) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "生成令牌失败");
        }
        return CommonReturnType.create(promoToken);
}
```

（2-3）`PromoServiceImpl/generateSecondKillToken()`生成令牌

- 首先检查redis里的活动商品库存是否还有余量，并检查活动是否正在进行。
- 通过`UUID.randomUUID()`设置秒杀令牌token，将(promoId+userId+itemId，token）放入redis里，并设置有效时间。

```java
//PromoServiceImpl
	@Override
    public String generateSecondKillToken(Integer promoId, Integer itemId, Integer userId) {

        //如果缓存里的库存已经卖完了，则返回错误信息
        if(!redisTemplate.hasKey("promo_item_stock_"+itemId)) {
            return null;
        }

        PromoDO promoDO = promoDOMapper.selectByPrimaryKey(promoId);

        //dataobject->model
        PromoModel promoModel = convertFromDataObject(promoDO);
        if(promoModel == null){
            return null;
        }

        //判断当前时间是否秒杀活动即将开始或正在进行
        if(promoModel.getStartDate().isAfterNow()){
            promoModel.setStatus(1);
        }else if(promoModel.getEndDate().isBeforeNow()){
            promoModel.setStatus(3);
        }else{
            promoModel.setStatus(2);
        }
        if(promoModel.getStatus().intValue() != 2) {
            return  null;
        }
//        检查商品信息和登陆用户信息
        ItemModel itemModel = itemService.getItemByIdInCache(itemId);
        if(itemModel == null){
           return null;
        }
        UserModel userModel = userService.getuserByIdInCache(userId);
        if(userModel == null){
            return null;
        }

        //将redis内秒杀大闸减1
        long res = redisTemplate.opsForValue().increment("promo_door_count_"+itemModel.getId(), -1);
        if(res < 0) {
            return null;
        }

//      生成令牌token，将（promoId+UUID+userId+itemId，token）放入redis里。
        String token = UUID.randomUUID().toString().replace("-", "");
        redisTemplate.opsForValue().set("promo_token_"+promoId+"_userid_"+userId+"_itemid_"+itemId, token);
        redisTemplate.expire("promo_token_"+promoId+"_userid_"+userId+"_itemid_"+itemId, 5, TimeUnit.MINUTES);

        return token;
    }
```

（3）getItem页面l收到令牌后向`order/createorder`接口发起ajax请求，并在请求体中携带令牌。

```javascript
						$.ajax({
							type:"POST",
							contentType:"application/x-www-form-urlencoded",
							url:"http://"+g_host+"/order/createorder?token=" + token,
							data:{
								"itemId":g_itemVO.id,
								"amount":1,
								"promoId":g_itemVO.promoId,
								"promoToken":promoToken
							},
							xhrFields:{withCredentials:true},
							success:function(data){
								if(data.status == "success"){
									alert("下单成功");
									window.location.reload();
								}else{
									alert("下单失败，原因为"+data.data.errMsg);
									if(data.data.errCode == 20003){
										window.location.href="login.html";
									}
								}
							},
							error:function(data){
								alert("下单失败，原因为"+data.responseText);
							}
						});
```

（4）`OrderController/createOrder() `

- 当前线程尝试获取许可证，若获取失败则抛出异常
- 在redis里取出登陆凭证token对应的用户信息类UserModel，并检查登陆状态
- 从redis里取出promoId+userId+itemId对应的令牌token，拿来和请求体中带来的令牌比较。若相等则放行，否则抛出异常
- 通过一个最多20个线程的线程池负责分发线程来初始化库存流水并发送减库存事务消息。

> 库存流水StockLog用于检查业务层创建订单是否成功，它有一属性status表示状态：1表示刚初始化，2表示下单扣减库存成功，3表示下单回滚。

```java
//OrderController 
 
private ExecutorService executorService;
private RateLimiter orderCreateRateLimiter;

@PostConstruct
 public void init() {
     executorService = Executors.newFixedThreadPool(20);
     orderCreateRateLimiter = RateLimiter.create(300);
 }

 //封装下单请求
    @RequestMapping(value = "/createorder",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType createOrder(@RequestParam(name="itemId")Integer itemId,
                                        @RequestParam(name="amount")Integer amount,
                                        @RequestParam(name="promoId",required = false)Integer promoId,
                                        @RequestParam(name="promoToken",required = false)String  promoToken) throws BusinessException {
		
        //尝试获取许可证
		if(!orderCreateRateLimiter.tryAcquire()) {
            throw new BusinessException(EmBusinessError.RATELIMIT);
        }
        
        //获取请求url里的token
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }
        //在redis里通过token获取登陆用户信息
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get(token);
        if(userModel == null) {     //会话过期
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }

        //从redis里取秒杀令牌，并和请求传来的promoToken比较是否相同
        if(promoId != null) {
            String inRedisPromoToken = (String) redisTemplate.opsForValue().get("promo_token_"+promoId+"_userid_"+userModel.getId()+"_itemid_"+itemId);
            if(inRedisPromoToken == null || !StringUtils.equals(inRedisPromoToken, promoToken)) {
                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"令牌校验失败");
            }
        }

        //交由线程池创建的线程来初始化库存流水并发送减库存事务消息
        //在一台服务器上，同一时间内只有20个用户请求来下单，其他请求需要排队
        Future<Object> future =  executorService.submit(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                //初始化库存流水，并获取其状态
                String stockLogId = itemService.initStockLog(itemId, amount);

                //完成下单事务消息机制
                if(!mqProducer.transactionAsyncReduceStock(userModel.getId(), promoId, itemId,  amount, stockLogId)) {
                    throw new BusinessException(EmBusinessError.UNKNOWN_ERROR, "下单失败");
                }
                return null;
            }
        });
        try {
            future.get();
        } catch (InterruptedException e) {
            throw new BusinessException(EmBusinessError.UNKNOWN_ERROR);
        } catch (ExecutionException e) {
            throw new BusinessException(EmBusinessError.UNKNOWN_ERROR);
        }
        return CommonReturnType.create(null);
    }
```

（4-4）Rocketmq生产者MqProducer类

- `transactionAsyncReduceStock`方法负责创建一个事务消息并发送，然后判断返回结果sendResult的本地事务状态是回滚消息还是提交消息，以此返回true或false。
- 事务消息会被维护在messagebroker的中间件上，并在本地执行`executeLocalTransaction`方法。
- `executeLocalTransaction`方法负责执行业务层的创建订单方法`orderService.createOrder`，并返回事务执行状态`LocalTransactionState.COMMIT_MESSAGE`。
  - 如果在执行的过程中抛出异常，则将流水号状态设置为3，并返回回滚状态`LocalTransactionState.ROLLBACK_MESSAGE`。
- 如果在执行业务层方法过程中一直没有明确事务状态（比如方法在压力较大的情况下执行时间较长），此时事务默认状态为`LocalTransactionState.UNKNOW`。消息中间件针对UNKNOWN状态的事务会定期调用`checkLocalTransaction`方法来判断事务到底是什么状态。
  - `checkLocalTransaction`方法通过库存流水StockLogDO来判断状态：若为1或StockLogDO为空则返回UNKNOWN；若为2返回提交信息；若为3则回滚信息。



```java
//MqProducer

private TransactionMQProducer transactionMQProducer;

    @PostConstruct
    public void init() throws MQClientException {
        //新建消息的事务消费者并初始化，此处省略.
        
        //注册事务消费者的监听器
        transactionMQProducer.setTransactionListener(new TransactionListener() {
            /*
                * @param: message：transactionAsyncReduceStock方法的argsMap
             	* @param: arg ：
                * @description: 负责执行业务层的创建订单方法并返回状态
                * @return: org.apache.rocketmq.client.producer.LocalTransactionState
                */
            @Override
            public LocalTransactionState executeLocalTransaction(Message message, Object arg) {
                Integer itemId = (Integer)((Map)arg).get("itemId");
                Integer promoId = (Integer)((Map)arg).get("promoId");
                Integer amount = (Integer)((Map)arg).get("amount");
                Integer userId = (Integer)((Map)arg).get("userId");
                String stockLogId = (String)((Map)arg).get("stockLogId");
                try {
                    //当createOrder没有明确返回是成功还是回滚时（比如该方法在压力较大的情况下执行时间较长），消息的默认状态为UNKNOW。
                    //消息中间件针对UNKNOW状态的消息 会定期回调checkLocalTransaction方法来判断是什么状态
                    orderService.createOrder(userId, itemId, promoId, amount, stockLogId);
                }catch (BusinessException e) {
                    e.printStackTrace();
                    //若出错则先将流水号状态设置为回滚状态，并返回回滚
                    StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);
                    stockLogDO.setStatus(3);
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
                //提交事务消息
                return LocalTransactionState.COMMIT_MESSAGE;
            }
             /*
                * @param: messageExt ：在transactionAsyncReduceStock方法里设置的哈希表bodyMap
                * @description: 根据redis里的库存是否成功扣减，来判断是要返回COMMIT，ROLLBACK还是继续UNKNOW
                * @return: org.apache.rocketmq.client.producer.LocalTransactionState
                */
            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
                //
                String jsonStr = new String(messageExt.getBody());
                Map<String, Object> map = JSON.parseObject(jsonStr, Map.class);

                Integer itemId = (Integer)map.get("itemId");
                Integer amount = (Integer)map.get("amount");
                String stockLogId = (String)map.get("stockLogId");
                StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);

                if(stockLogDO == null) {
                    return LocalTransactionState.UNKNOW;
                }
                if(stockLogDO.getStatus().intValue() == 2) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }else if(stockLogDO.getStatus().intValue() == 1) {
                    return LocalTransactionState.UNKNOW;
                }
                return LocalTransactionState.ROLLBACK_MESSAGE;
            }
        });
    }

 //同步扣减库存的事务消息
    public boolean transactionAsyncReduceStock(Integer userId, Integer promoId, Integer itemId, Integer amount, String stockLogId) {
        Map<String, Object> bodyMap = new HashMap<>();

        bodyMap.put("itemId", itemId);
        bodyMap.put("amount", amount);
        bodyMap.put("stockLogId", stockLogId);

        //传进executeLocalTransaction方法的参数
        Map<String, Object> argsMap = new HashMap<>();
       argsMap.put("userId", userId);
       argsMap.put("promoId", amount);
       argsMap.put("itemId", itemId);
       argsMap.put("amount", amount);
       argsMap.put("stockLogId", stockLogId);

        Message message = new Message(topicName, "increase", JSON.toJSON(bodyMap).toString().getBytes(Charset.forName("UTF-8")));
        TransactionSendResult sendResult = null;
        try {
            //发送事务型消息：（1）往消息队列里投递prepare状态的消息；（2）这个消息被维护在messagebroker的中间件上面，该消息会在本地执行executeLocalTransaction方法
            sendResult =  transactionMQProducer.sendMessageInTransaction(message, argsMap);
        } catch (MQClientException e) {
            e.printStackTrace();
            return  false;
        }

       if(sendResult.getLocalTransactionState() == LocalTransactionState.ROLLBACK_MESSAGE) {
           return false;
       }else  if(sendResult.getLocalTransactionState() == LocalTransactionState.COMMIT_MESSAGE) {
           return true;
       }else {
           return false;
       }
    }
```

（5）业务层创建订单方法`OrderServiceImpl/createOrder`

- 从redis里取出用户，若没有则从数据库里，再设置到redis里
- 在redis里减掉活动商品库存：如果库存量已经减为0了，则在redis里设置(itemId, true)表示该商品已销售完；如果redis里没有活动商品则到数据库里减库存。
- 创建一个新订单，并放入订单表中，并在商品表里加上销售量
- 将库存流水StockLogDO的状态设置为2，表示创建订单成功，然后修改库存流水表里对应的记录。



```java
//OrderServiceImpl

	@Override
    @Transactional
    public OrderModel createOrder(Integer userId, Integer itemId, Integer promoId, Integer amount, String stockLogId) throws BusinessException {
        //1.从redis里取出用户
        ItemModel itemModel = itemService.getItemByIdInCache(itemId);
        if(itemModel == null){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"商品信息不存在");
        }
        
        if(amount <= 0 || amount > 99){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"数量信息不正确");
        }


        //2.落单减库存
        boolean result = itemService.decreaseStock(itemId,amount);
        if(!result){
            throw new BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);
        }

        //3.订单入库
        OrderModel orderModel = new OrderModel();
        orderModel.setUserId(userId);
        orderModel.setItemId(itemId);
        orderModel.setAmount(amount);
        if(promoId != null){
            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());
        }else{
            orderModel.setItemPrice(itemModel.getPrice());
        }
        orderModel.setPromoId(promoId);
        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(new BigDecimal(amount)));

        //生成orderId:交易流水号
        orderModel.setId(generateOrderNo());
        OrderDO orderDO = convertFromOrderModel(orderModel);
        orderDOMapper.insertSelective(orderDO);

        //3.加上商品的销量
        itemService.increaseSales(itemId,amount);

        //设置库存流水状态为成功
        StockLogDO stockLogDO = stockLogDOMapper.selectByPrimaryKey(stockLogId);
        if(stockLogDO == null) {
            throw new BusinessException(EmBusinessError.UNKNOWN_ERROR);
        }
        stockLogDO.setStatus(2);
        stockLogDOMapper.updateByPrimaryKeySelective(stockLogDO);

        //4.返回前端
        return orderModel;
    }
	//从redis里取出用户，若没有则从数据库里，再设置到redis里
    @Override
    public ItemModel getItemByIdInCache(Integer id) {
        ItemModel itemModel = (ItemModel)redisTemplate.opsForValue().get("item_validate_" + id);
        if(itemModel == null) {
            itemModel = this.getItemById(id);
            redisTemplate.opsForValue().set("item_validate_"+id, itemModel);
            redisTemplate.expire("item_validate_"+id, 10, TimeUnit.MINUTES);
        }
        return itemModel;
    }

//5.2  
//ItemServiceImpl
    @Override
    @Transactional
    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {
        //首先在redis里减库存
        long  result = redisTemplate.opsForValue().increment("promo_item_stock_"+itemId, amount.intValue()*-1);
        if(result > 0){    //更新库存成功
            return true;
        }else if(result == 0) {         //库存已经扣减为0了，此时需要表示库存已经卖完
            redisTemplate.opsForValue().set("promo_item_stock_invalid_"+itemId, "true");
            return true;
        }
        else{
            //到数据库里减
            increaseSales(itemId, amount);
            return false;
        }
    }
```

（6）Rocketmq的消费端MqConsumer负责将商品的减库存量同步进商品表里

- 设置消费者的consumer_group，Rocketmq部署的服务器ip和订阅的topicName：stock。
- 注册消息的监听器：在生产者传来的消息message里存有一个哈希表bodyMap。里面存放了商品id和购买数量amount。在商品表里找到商品并减去amout个库存。

```java
//MqConsumer

/*

 	    Message message = new Message(topicName, "increase", JSON.toJSON(bodyMap).toString().getBytes(Charset.forName("UTF-8")));
 	    
        TransactionSendResult sendResult = null;
        try {
            //发送事务型消息
            sendResult =  transactionMQProducer.sendMessageInTransaction(message, argsMap);
        }
*/
	@PostConstruct
    public void init() throws MQClientException {
        consumer = new DefaultMQPushConsumer("stock_consumer_group");
        consumer.setNamesrvAddr(nameAddr);
        //订阅topicName的所有消息
        consumer.subscribe(topicName, "*");
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            //CONSUME_SUCCESS表示消息已被消费，因此将数据同步到数据库里。
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                Message msg = list.get(0);
                String jsonStr = new String(msg.getBody());
                Map<String, Object> map = JSON.parseObject(jsonStr, Map.class);

                Integer itemId = (Integer)map.get("itemId");
                Integer amount = (Integer)map.get("amount");

                itemStockDOMapper.decreaseStock(itemId, amount);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });

        //开启
        consumer.start();
    }
```

