# 注解

## @ExceptionHandler

**@ExceptionHandler**

如果一个Controller类里有方法加了@ExceptionHandler，那么这个Controller的其他方法中没有捕获的异常就会以参数的形式传入进来。比如下方handlerException方法。

```java
	@RequestMapping("/get")
    @ResponseBody
    public CommonReturnType getUser(@RequestParam(name = "id")Integer id) throws BusinessException{
        UserModel userModel = userService.getUserById(id);
        if(userModel == null) {
            throw new BusinessException(EmBusinessError.USERR_NOT_EXIST);		//此处抛出异常
        }
        //...
    }	

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    public Object handlerException(HttpServletRequest request, Exception ex) {
        BusinessException buEx = (BusinessException)ex;
        CommonReturnType commonReturnType = new CommonReturnType();
        commonReturnType.setStatus("fail");

        Map<String, Object> responseMap = new HashMap<>();
        responseMap.put("errCode", buEx.getErrCode());
        responseMap.put("errMsg", buEx.getErrMsg());
        commonReturnType.setData(responseMap);
        return commonReturnType;
    }
```

可以看一下方法参数ex的值

<img src="https://user-gold-cdn.xitu.io/2020/7/22/17376ab7d7f0b88f?w=1288&amp;h=751&amp;f=png&amp;s=92845" style="zoom:67%;" />

你可以定义一个基类BaseController，然后让其他Controller类都继承自它，这样子类Controller抛出的异常都可以在父类BaseController里捕获。

## **@ResponseStatus**

它用于修饰一个类或者一个方法：

- 修饰一个类的时候一般是一个异常类对类中所有方法起作用；
- 当修饰一个方法时则是当该方法被触发且内部发生@ResponseStatus修饰异常时才起作用。

当它修饰一个异常类时，如果这个异常类被抛出，则使用该注解上的**error code 和 error reasoon 返回给客户端**

```java
/**
 * 自定义一个异常类，用@ResponseStatus修饰，当这个异常类型发生时用403和"Are you okay?"输出
 */
@ResponseStatus(value = HttpStatus.FORBIDDEN, reason = "Are you okay?")
public class MyException extends RuntimeException {
}
```

抛出异常：

```java
@Controller
@RequestMapping(value="/web")
public class MyController {

    @RequestMapping(value="/hi", method = RequestMethod.GET)
    @ResponseBody
    public String sayHi(@RequestParam("name") String name){
        if ("yang".equals(name)){
            throw new MyException();
        }
       //...
    }
   
}
```

展示图：

![](https://user-gold-cdn.xitu.io/2020/7/22/173773b57b2a9a50?w=601&h=151&f=png&s=49654)



## @CrossOrigin

```javascript
 $.ajax({
                type:"POST",
                contentType:"application/x-www-form-urlencoded",
                url:"http://localhost:8080/user/getotp",
                data:{
                    "telphone":$("#telphone").val(),
                },
                //允许跨域请求
               // xhrFields:{withCredentials:true},
                success:function (data) {
                    if (data.status=="success") {
                        alert("otp已经发送到了您的手机，请注意查收");
                        window.location.href="register.html";
                    }else {
                        alert("otp发送失败，原因为" + data.data.errMsg);
                    }
                },
                error:function (data) {
                    alert("otp发送失败，原因为"+data.responseText);
                }
            });
```

在本项目中，ajax请求的页面是放在独立于项目的另一个文件夹里，也就是说，ajax对应的域是本地文件，但是我们请求的服务器是localhost域名。虽然请求能够到达服务端，并且服务端可以返回，但ajax认为两者的域不同，因而走不到

![](https://user-gold-cdn.xitu.io/2020/7/26/17388f1eea903364?w=1789&h=46&f=png&s=88966)

Springboot提供了一个@CrossOrigin ，该注解可以在响应头上添加`Access-Controller-Allow-Origin`字段，其值为*。

## @Transactional

注解在方法上表示方法里的所有sql操作为一个事务。



## @Param

常用在Mapper类里：

```java
//com.jnju.dao.ItemStockDaoMapper
int decreaseStock(@Param("itemId") Integer itemId, @Param("amount") Integer amount);
```

它对应映射文件里传入的参数值：

```xml
  <update id="decreaseStock">
    update item_stock
    set stock = stock - #{amount}
    where item_id = #{itemId} and stock >= #{amount}
  </update>
```



## @PostConstruct



# Spring

## 属性检查

之前在service层实现的注册功能里 首先要对 输入框里输入的信息组成的userModel进行检查

```java
//com.jnju.service.impl.UserServiceImpl

	@Override
    @Transactional
    public void register(UserCompleModel userModel) throws BusinessException{
        if(userModel == null) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
        }
        if(StringUtils.isEmpty(userModel.getName()) || userModel.getGender() == null ||
                userModel.getAge() == null || StringUtils.isEmpty(userModel.getTelephone())) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
       }

        //...
    }
```

我们可以通过javax validation类简化 这段对userModel属性检查的代码

首先引入依赖：

```xml
        <!-- hibernate-validator -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
            <version>6.0.17.Final</version>
        </dependency>
```



（1）设置了一个存储错误信息的类ValidatorResult

```java
package com.jnju.validator;
public class ValidatorResult {
    private boolean hasErrors = false;
    private Map<String, String> errMsgMap = new HashMap<>();
	//getter，setter

    public String getErrMsg() {
        //逗号分隔的字符串
        return StringUtils.join(errMsgMap.values().toArray(), ",");
    }
}
```

（2）一个检查是否有错误信息的类ValidatorImpl，它继承自InitializingBean接口，并实现为bean提供了属性初始化后的处理方法afterPropertiesSet。凡是继承该接口的类，在bean的属性初始化后都会执行该方法。

```java
import javax.validation.Validation;
import javax.validation.Validator;

@Component
public class ValidatorImpl implements InitializingBean {
    private Validator validator;

    public ValidatorResult validate(Object bean) {
        ValidatorResult result = new ValidatorResult();
        Set<ConstraintViolation<Object>> constraintViolations =  validator.validate(bean);
        if(constraintViolations.size() > 0) {
            result.setHasErrors(true);
            //遍历constraintViolations里的每一个元素constraintViolation
            constraintViolations.forEach(constraintViolation->{
                String propertyName = constraintViolation.getPropertyPath().toString();
                String errMsg = constraintViolation.getMessage();
                result.getErrMsgMap().put(propertyName, errMsg);
            });
        }
        return  result;
    }

     @Override
    public void afterPropertiesSet() throws Exception {
        this.validator = Validation.buildDefaultValidatorFactory().getValidator();
    }
}
```

（3）设置参数检查

```java
/*
    UserDao只是对应数据表user，
    实际的用户模型里还包括密码encrptPassword
*/
public class UserCompleModel {
    private Integer id;
    @NotBlank(message = "用户名不能为空")
    private String name;
    @NotNull(message = "性别必须填写")
    private Byte gender;
    @NotNull(message = "年龄必须填写")
    @Min(value = 0, message = "年龄必须大于0")
    @Max(value = 200, message = "年龄必须小于200")
    private Integer age;
    @NotBlank(message = "电话不能为空")
    private String telephone;

    private String registerMode;

    private String thridPartyId;
    @NotBlank(message = "密码不能为空")
    private String encrptPassword;
    //...
}
```

（4）在代码中判断参数的值是否正确。

```java
//com.jnju.service.impl.UserServiceImpl

	@Override
    @Transactional
    public void register(UserCompleModel userModel) throws BusinessException{
        if(userModel == null) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
        }
//        if(StringUtils.isEmpty(userModel.getName()) || userModel.getGender() == null ||
//                userModel.getAge() == null || StringUtils.isEmpty(userModel.getTelephone())) {
//            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);
//        }
        //代替上面注释代码的判断
        ValidatorResult result = validator.validate(userModel);
        if(result.isHasErrors()) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, result.getErrMsg());
        }
        //...
    }
```











# 数据库

## 设计表

### 三种模型表

用户信息被设计为用户信息表和用户密码表；商品信息被设计为商品信息表和商品销量表。

每个信息在程序设计中又分为三种模型类：

（1）在model包下的模型类，比如ItemDo，ItemStockDo等。这些类对应数据库里的表，mabatis里传入的参数都是该模型类。

（2）在controller.viewObject包下的以Vo为后缀名的模型类，比如ItemVo等。由于有些信息的属性不需要在前端展示，因此设计这些类用于返回给前端。

（3）在service.completeModel包下模型类。这种类对应着设计的信息，比如ItemModel是商品信息，它是ItemStockDo和ItemDo两者的结合。

> 在项目里ItemModel，ItemVo的price字段是BigDecimal，而数据库模型类ItemDao的price字段是Double类型。这是因为 java里的double在前端展示会出现精度问题，因此使用BigDecimal



### 订单流水号

在订单表order_info里，其字段id不是递增的，而是我们自己自定义的订单流水号。

```java
/*
        * @param:
        * @description: 生成16位订单号。该方法包裹在事务方法createOrder里面。
        *               如果方法createOrder回滚，那么SequenceInfoDao的值也会跟着回滚
        *               但我们不希望值回滚，因此我们可以使用propagation属性的REQUIRES_NEW字段
        *               该字段表示无论该方法是否在事务中，它都会开启一个事务，并在执行完后提交事务。
        * @return: java.lang.String
    */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private String generateOrderNo() {
        //前8位是时间信息：年月日
        StringBuilder orderId = new StringBuilder();
        LocalDateTime now = LocalDateTime.now();
        String nowDateStr = now.format(DateTimeFormatter.ISO_DATE).replace("-", "");
        orderId.append(nowDateStr);

        //中间6位是自增序列
        int sequence = 0;
        SequenceInfoDao sequenceInfoDao = sequenceInfoDaoMapper.getSequenceByName("order_info");
        sequence = sequenceInfoDao.getCurValue();
        //下一次获取的值是步长step加上当前值
        sequenceInfoDao.setCurValue(sequenceInfoDao.getCurValue() + sequenceInfoDao.getStep());
        sequenceInfoDaoMapper.updateByPrimaryKeySelective(sequenceInfoDao);
        //不足6位的补0
        String sequenceStr = String.valueOf(sequence);
        for(int i=0; i<6-sequenceStr.length(); i++) {
            orderId.append(0);
        }
        orderId.append(sequenceStr);
        //最后2位是分库分表位。
        orderId.append("00");

        return orderId.toString();
    }
```

此处订单id是我们自定义的流水号，它由8位时间信息+自增序列+分库分表位组成。

其中流水号的自增序列涉及到数据表sequence_info。每当新增一个流水号时，都会从该表里的数据表名name对应的记录里提取出curValue作为其中间6位数（不足补0），然后下一次的curValue就等于curValue+step（无论添加订单的事务操作是否是执行还是回滚，它都会加上step）。

```java
/*
	CREATE TABLE `sequence_info`  (
      `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL,
      `current_value` int(11) NOT NULL DEFAULT 0,
      `step` int(11) NOT NULL DEFAULT 0,
      PRIMARY KEY (`name`) USING BTREE
    ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_bin ROW_FORMAT = Compact;
    INSERT INTO `sequence_info` VALUES ('order_info', 6, 1);
*/
public class SequenceInfoDao {
    private String name;		//涉及到的表名，此处是order_info

    private Integer curValue;

    private Integer step;
    //getter，setter
}
```

**for update**

在通过表名name获取sequence_info记录时，需要加上行级锁，也就是for update。

```sql
  <select id="getSequenceByName" parameterType="java.lang.String" resultMap="BaseResultMap">
    select 
    <include refid="Base_Column_List" />
    from sequence_info
    where name = #{name,jdbcType=VARCHAR} for update
  </select>
```

它会把查询到的数据加上锁，其他事务无法对其进行更新。等到事务提交了才释放锁。





## insertSelective和insert

在自动生成的mapper映射文件里，有两个添加操作的sql语句：insertSelective和insert。

（1）insertSelective会在添加操作前检查传进来的UserDao对象里的对应字段是否为 null：如果为null则不添加该字段，也就是取决于数据库里的默认值。

（2）insert操作不会检查字段是否为null，也就是如果为null，则会覆盖掉数据库的默认值。





## useGeneratedKeys和keyProperty

当我们要在程序里使用到自增id时，比如说：

```java
        UserDao userDao = convertToUserDao(userModel);
        try {
            userDaoMapper.insertSelective(userDao);
        }catch (DuplicateKeyException e) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "手机号已重复");
        }
        userModel.setId((userDao.getId()));
```

我们要在映射文件里指定自增的id：

```
  <insert id="insertSelective" parameterType="com.jnju.model.UserDao" keyProperty="id" useGeneratedKeys="true">
```



## 唯一索引telephone

注册功能的实现需要电话号码，为了保证每条记录里telephone字段的唯一性，我们需要将其设置为唯一索引。

如果在添加注册用户的insertSelective方法中出现了DuplicateKeyException异常，则表示添加的唯一性索引字段telephone与数据库里原有的记录有重复。

```java
        try {
            userDaoMapper.insertSelective(userDao);
        }catch (DuplicateKeyException e) {
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR, "手机号已重复");
        }
```



# 工具类

## DateTime

秒杀活动的开始时间和结束时间是使用 org.joda.time.DateTime类，在数据库使用的是datetime，对应的数据库模型类PromoDao使用的是Date类。

在用于转化成给前端展示的ItemVo中开始时间是String类型。

这是如果DateTime在json数据化时，显示出来会出现错误：

![](https://user-gold-cdn.xitu.io/2020/7/27/1738f615b820902a?w=281&h=398&f=png&s=114635)





# jmeter工具

[jmeter](https://jmeter.apache.org/download_jmeter.cgi)是一个压力测试工具，你可以通过它来模拟多线程对某一接口的请求并查看其输出接口。

新建步骤：

- 右键测试计划->添加->线程->线程组。
- 右键线程组->添加->取样器->HTTP请求。
- 右键线程组->添加->监听器->查看结果树
- 右键线程组->添加->监听器->聚合报告。

下面来看一下上述四个功能。

（1）线程组。其中线程数表示并发的线程数x；Rampu-Up时间表示在该时间内启动x个线程；循环次数表示每个线程发起的请求数量。

你可以通过上方的绿三角形来启动，右边的符号可可以清空上次请求的记录。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a35937ace805?w=1527&h=666&f=png&s=48118)



（2）HTTP请求。你可以在此规定请求协议，类型以及服务器的IP（或域名）和端口

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a405889534a5?w=1529&h=601&f=png&s=52312)

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a406476857ce?w=1521&h=556&f=png&s=48801)



察看结果树。你可以在此观察到响应的返回内容。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a434e5cdbfa2?w=1516&h=494&f=png&s=49220)



（4）聚合报告。你可以在此检查所有请求的数据。比如说响应时间的平均值，中位值和90%，95%，99%的响应时间等等。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a3587dad87c0?w=1515&h=512&f=png&s=41407)



# 项目出现的问题

## 并发容量问题

**模拟场景**

通过jmeter工具来启动超多个线程：

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a46ed72c7aaa?w=1520&h=604&f=png&s=222875)

发起对服务器的get请求：

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a47762c5d95b?w=1510&h=477&f=png&s=182123)

运行后会发现响应数据出现了错误。

![](https://user-gold-cdn.xitu.io/2020/7/29/1739a46e4f3e80bd?w=1483&h=694&f=png&s=528710)

通过下面命令

```
ps -ef | grep java 查看正在进行的java线程

pstree -p java进程号 | wc - l 统计java进程下的线程数
```

我们可以得知在服务端下java进程下最多有x个线程，最多服务于x个线程。而5000个线程远大于x，从而导致请求被拒绝。

**解决方案**

我们可以在配置文件application.properties中对springboot的内嵌tomcat进行一些配置：

```
server.tomcat.accept-count 				等待队列长度，默认100

server.tomcat.max-connections:			最大可被连接数，默认10000

server.tomcat.max-threads				最大工作线程数，默认200

server.tomcat.min-spare-threads			最小工作线程数，默认10

默认配置下，连接超过10000后出现拒绝连接情况

默认配置下，触发的请求超过200(工作线程)+100（等待队列）后拒绝处理
```



## keep alive问题

**什么是KeepAlive**

对于非KeepAlive模式：每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；

当使用Keep-Alive模式（持久连接）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

[![HTTP_persistent_connection.svg](https://byvoid.com/attachments/wp/2011/07/450px-HTTP_persistent_connection.svg_.png)](https://byvoid.com/attachments/wp/2011/07/450px-HTTP_persistent_connection.svg_.png)

> http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive”，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive。

**keep alive问题**

如果服务端对keep alive没有限制时间，那么可能出现一些问题：

- 客户端将网页空闲，不去做任何响应。那么这条连接对于服务端来说就是废连接
- 攻击者恶意利用keep alive发起DDOS攻击

**解决方案** 

因此我们需要定制化内嵌Tomcat，我们需要关注两个参数：

```
keepAliveTimeOut		多少毫秒后不响应的断开keepalive
maxKeepAliveRequests	多少次请求后keepalive断开失效
```

这两个参数不是在配置文件里定义的，而是使用`WebServerFactoryCustomizer<ConfigurableServletWeb ServerFactory>`定制内嵌tomcat配置：

```java
package com.jnju.miaosha_project.config;
/*
    当springboot启动后，会将server.tomcat的参数加载到protocol内，然后又会组装到
    ConfigurableWebServerFactory对象里
*/
@Component
public class WebServerConfiguration implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {
    @Override
    public void customize(ConfigurableWebServerFactory factory) {
        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(new TomcatConnectorCustomizer() {
            @Override
            public void customize(Connector connector) {
                Http11NioProtocol protocol = (Http11NioProtocol)connector.getProtocolHandler();

                //30秒内没有请求则服务端自动断开keepalive连接
                protocol.setKeepAliveTimeout(30000);
                //当客户端发送超过10000个请求则自动断开keepalive连接
                protocol.setMaxKeepAliveRequests(10000);
                protocol.setM
            }
        });
    }
}
```



## 单Web容器上限

虽然前面我们增加了tomcat的线程，变更了线程池以及对keep-alive做了优化，但容量问题依旧存在。随着并发容量压力的增大，HTTP请求的响应时间随之变长，吞吐量（每秒处理完的请求数）在达到一定值后就会无法上升。

对于单Web容器上限，我们考虑两个角度：

（1）线程数量：当进程调度的线程数达到一定值后（比如4核cpu 8G内存单进程调度线程数为800-1000），如果超出这个值，CPU的大量时间将会消耗在线程调度和cpu的内存切换。因此线程数不是越多越好。

（2）等待队列长度：如果并发请求线程数超过了最大线程池时，那么就会进入等待队列。队列的长度不能无限长，因为对应的缓冲区是消耗内存的，出队和入队也消耗cpu。

如果线程数超出了上述两个的正常范围，我们应该将单台web容器扩展为多台。



## Mysql的查询效率

- 主键查询：千万级别数据 = 1-10ms
- 唯一索引查询：千万级别数据 = 10-100ms
- 非唯一索引查询：千万级别数据 = 100-1000ms
- 无索引：百万条数据 = 1000ms +

我们要保证查询操作尽可能是在唯一索引，甚至是主键查询上，如果前两者无法保证，比如根据订单状态查询订单表，那么订单状态就必须是非唯一索引查询，如果是无索引查询相当于全表查询，这种方式对于大型应用来说是不可接受的。

如果数据库里数据达到了千万级别后，非唯一索引查询也会产生一定的压力，此时我们就需要考虑分库分表，扩容热点数据。



## 水平扩展

之前的部署方式是将web容器同时部署了jar包和mysql服务器，也就是说：web容器不仅要服务于mysql数据库，还要服务于应用服务器。

<img src="https://user-gold-cdn.xitu.io/2020/7/30/1739d400da9c71b9?w=792&amp;h=642&amp;f=png&amp;s=96713" style="zoom:67%;" />



我们可以水平部署应用服务器，单点存储数据库，此处我们需要一台nginx来做反向代理的负载均衡。总的来说，分布式部署需要一台数据库服务器，一台nginx服务器，两台应用服务器。

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dabf4cf1925242baba60df438fcb99cf~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />



## 多个应用服务器出现的session不一致

在前面我们将jar包部署在两个应用服务器中，并用nginx反向代理到这两个应用服务器中。

在该程序中，程序会在用户登陆后，将IS_LOGIN放在session里。当页面执行创建订单功能createOrder方法时，首先会通过session里IS_LOGIN的值来判断用户是否登陆。这是基于cookie传输sessionid，这个session则是由tomcat来实现。

对于多个应用服务器而言，如果用户登陆的请求是放在其中一个应用服务器里，也就是说iIS_LOGIN标识是放在那个应用服务器里的tomcat里，而创建订单的请求则是到了另一个应用服务器里，但此时那个应用服务器的tomcat的session无法找到IS_LOGIN标识符，因此造成用户没有登陆的现象而无法创建订单的问题。

**解决方案**

生成一个token凭证，将token和登陆用户存储在部署于数据库服务器的redis里。当我们判断用户是否登陆时，查询redis即可。



## 交易性能的瓶颈

**交易流程**

在商品信息getitem页面里，发起下单请求，传入参数为商品id，下单数量（固定为1个），活动id。

```javascript
$.ajax({
				type:"POST",
				contentType:"application/x-www-form-urlencoded",
				url:"http://"+g_host+"/order/createorder?token=" + token,
				data:{
					"itemId":g_itemVO.id,
					"amount":1,
					"promoId":g_itemVO.promoId
				},
				xhrFields:{withCredentials:true},
				success:function(data){
					if(data.status == "success"){
						alert("下单成功");
						window.location.reload();
					}else{
						alert("下单失败，原因为"+data.data.errMsg);
						if(data.data.errCode == 20003){
							window.location.href="login.html";
						}
					}
				},
				error:function(data){
					alert("下单失败，原因为"+data.responseText);
				}
			});

```

OrderController接收请求后：根据请求url中传入的token判断用户是否登陆，然后从redis里取得用户信息，调用orderService的createOrder方法，传入的参数为用户id，商品id，商品对应活动id和下单数量。

```java
//OrderController

	//封装下单请求
    @RequestMapping(value = "/createorder",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType createOrder(@RequestParam(name="itemId")Integer itemId,
                                        @RequestParam(name="amount")Integer amount,
                                        @RequestParam(name="promoId",required = false)Integer promoId) throws BusinessException {
        
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }

        //获取用户的登陆信息
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get(token);
//        UserModel userModel = (UserModel)httpServletRequest.getSession().getAttribute("LOGIN_USER");
        if(userModel == null) {     //会话过期
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }
        OrderModel orderModel = orderService.createOrder(userModel.getId(),itemId,promoId,amount);

        return CommonReturnType.create(null);
    }


```

OrderService：

- 检查用户和下单数量：判断对应传入的用户id能否找到对应用户，再判断下单数量是否正常。
- 检查活动信息：判断传入的活动id是否和商品对应的活动id相等，以及商品对应的活动状态是否不等于2
- 执行减库存操作，并判断是否成功
- 根据传进方法的三个参数构建订单信息，生成订单id。在订单数据库中添加订单
- 添加商品销量

```java
//OrderService

	@Override
    @Transactional
    public OrderModel createOrder(Integer userId, Integer itemId, Integer promoId, Integer amount) throws BusinessException {
        //1.校验下单状态,下单的商品是否存在，用户是否合法，购买数量是否正确。执行数据库语句
        ItemModel itemModel = itemService.getItemById(itemId);
        if(itemModel == null){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"商品信息不存在");
        }
		
        UserModel userModel = userService.getUserById(userId);	//执行数据库语句
        if(userModel == null){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"用户信息不存在");
        }
        if(amount <= 0 || amount > 99){
            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"数量信息不正确");
        }

        //2校验活动信息
        if(promoId != null){
            //（1）校验对应活动是否存在这个适用商品
            if(promoId.intValue() != itemModel.getPromoModel().getId()){
                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"活动信息不正确");
                //（2）校验活动是否正在进行中
            }else if(itemModel.getPromoModel().getStatus().intValue() != 2) {
                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"活动信息还未开始");
            }
        }

        //3.落单减库存。执行数据库语句
        boolean result = itemService.decreaseStock(itemId,amount);
        if(!result){
            throw new BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);
        }

        //4.订单入库
        OrderModel orderModel = new OrderModel();
        orderModel.setUserId(userId);
        orderModel.setItemId(itemId);
        orderModel.setAmount(amount);
        //设置订单的正确价格
        if(promoId != null){
            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());
        }else{
            orderModel.setItemPrice(itemModel.getPrice());
        }
        orderModel.setPromoId(promoId);
        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(new BigDecimal(amount)));

        //生成交易流水号,订单号
        orderModel.setId(generateOrderNo());
        OrderDO orderDO = convertFromOrderModel(orderModel);
        //执行数据库语句
        orderDOMapper.insertSelective(orderDO);

        //5加上商品的销量。执行数据库语句
        itemService.increaseSales(itemId,amount);
        return orderModel;
    }




```

用一张图来说明流程：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb330e3d88f441093c2dbd6fe56c811~tplv-k3u1fbpfcp-zoom-1.image" style="zoom: 67%;" />

我们发现交易操作对总共会对数据库执行6次IO操作，并且我们对数据库的减库存操作decreaseStock是有一个行锁等待时间

```java
ItemModel itemModel = itemService.getItemById(itemId);	//从商品表中获取商品信息

UserModel userModel = userService.getUserById(userId);	//用户表中获取用户信息

boolean result = itemService.decreaseStock(itemId,amount);	//在商品库存表中减少库存量

orderDOMapper.insertSelective(orderDO);		//在订单表中添加订单信息

itemService.increaseSales(itemId,amount);	//在商品表中增加销量
```

**如何优化**

（1）对于第一，二条操作，我们可以优化成从redis里取，如下代码所示：

```java
//ItemServiceImpl

  @Override
    public ItemModel getItemByIdInCache(Integer id) {
        ItemModel itemModel = (ItemModel)redisTemplate.opsForValue().get("item_validate_" + id);
        if(itemModel == null) {
            itemModel = this.getItemById(id);
            redisTemplate.opsForValue().set("item_validate_"+id, itemModel);
            redisTemplate.expire("item_validate_"+id, 10, TimeUnit.MINUTES);
        }
        return itemModel;
    }

//UserServiceImpl
    @Override
    public UserModel getuserByIdInCache(Integer id) {
        UserModel userModel = (UserModel)redisTemplate.opsForValue().get("user_validate_"+id);
        if(userModel == null) {
            userModel = this.getUserById(id);
            redisTemplate.opsForValue().set("user_validate_"+id, userModel);
            redisTemplate.expire("user_validate_"+id, 10, TimeUnit.MINUTES);
        }
        return userModel;
    }
```

然后修改获取商品信息和用户信息的方法：

```java
ItemModel itemModel = itemService.getItemByIdInCache(itemId);
UserModel userModel = userService.getuserByIdInCache(userId);
```



# 初识redis

## 配置

**修改redis配置文件**

在将redis下载到数据库服务器后，我们首先修改配置文件。

我们可以将redis监听在内网ip地址里，这样应用服务器里的程序所绑定的redis.host就是内网ip地址。

进入redis/redis.conf文件，它默认绑定在0.0.0.0，也就是所有能连接到数据库服务器Ip（无论是外网ip还是内网ip）都可以使用这个redis：

```
bind 加上数据库服务器的私网ip。
#注释掉里面的bind 127.0.0.1语句
protected-mode no #修改保护模式
```

然后执行` src/redis-server ./redis.conf &`指定配置文件并在后台启动。



**存储session到redis里**

导入依赖：

```xml
        <!--redis-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--session-->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
            <version>2.2.0.RELEASE</version>
        </dependency>
```

springboot会将自己对session的一套管理方式存储在redis里。

在项目的主配置文件里：

```
#redis    
spring.redis.host=127.0.0.1
spring.redis.port=6379
    #使用第10个database
spring.redis.database=10

#设置jedis连接池
spring.redis.jedis.pool.max-active=50
spring.redis.jedis.pool.min-idle=20
```

> **如果某个类涉及到了redis的操作，则这个类及其属性类必须要序列化：implements Serializable 。**比如此处的UserModel

执行`redis-server`开启redis服务后，执行项目，并在执行`redis-cli`开启客户端，执行如下命令：

```
select 10
keys *
```

即可发现存储session的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30e9abc9410e4d0ca7decdc770234d68~tplv-k3u1fbpfcp-zoom-1.image)



## 基于token的分布式会话实现

**概念**

在前面我们是基于cookie传输sessionid

```java
//登陆后将标识符放入session里  
this.httpServletRequest.getSession().setAttribute("IS_LOGIN",true);
 this.httpServletRequest.getSession().setAttribute("LOGIN_USER",userModel);

//创建订单时根据session验证是否登陆
        Boolean isLogin = (Boolean) httpServletRequest.getSession().getAttribute("IS_LOGIN");
        if(isLogin == null || !isLogin.booleanValue()){
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }

```

对于一个企业应用而言，我们不光需要支持html页面，可能还需要支持一些移动设备，微信小程序，安卓，ios等。这些操作不一定支持cookie传输sessionid，并且网络的cookie规则可能会被改变。这些都是开发人员无法保证的，因此我们都是采用基于token传输类似sessionid的方式来完成类似的操作。

**如何实现**

首先我们在登陆方法login下创建一个token并放入redis里

```java
@Autowired
private RedisTemplate redisTemplate;


    @RequestMapping(value = "/login",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})
    @ResponseBody
    public CommonReturnType login(@RequestParam(name="telphone")String telphone,
                                  @RequestParam(name="password")String password) throws BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {
        //...
		//登陆凭证token, UUID
        String uuidToken = UUID.randomUUID().toString();
        uuidToken = uuidToken.replace("-","");
        //token和用户信息作为键值对
        redisTemplate.opsForValue().set(uuidToken, userModel);
        redisTemplate.expire(uuidToken, 1, TimeUnit.HOURS); //超时时间
		//...
 		return CommonReturnType.create(null);
    }
/*
uuid：89814521-33e0-40fd-8c33-74b4184f3cf9
redis存储的键值对："\xac\xed\x00\x05t\x00$58dbc259-bbf6-404d-8df9-52492dc4d8ad"
*/
```

在登陆页面login.html中取出data里的token

```js
			success:function(data){
					if(data.status == "success"){
						alert("登陆成功");
						var tooken = data.data;				//取出
						window.localStorage["token"] = tooken;
						window.location.href="listitem.html";
					}else{
						alert("登陆失败，原因为"+data.data.errMsg);
					}
				},
				error:function(data){
					alert("登陆失败，原因为"+data.responseText);
				}
			});
```

在商品页面getitem.html里，取出token并在动态请求url里放入url中。

```js
jQuery(document).ready(function(){
		$("#createorder").on("click",function(){
		var token = window.localStorage["token"];
		if(token == null) {
			alert("你还没有登陆，无法下单");
			window.location.href="login.html";
			return false;
		}
			$.ajax({
				type:"POST",
				contentType:"application/x-www-form-urlencoded",
				url:"http://"+g_host+"/order/createorder?token=" + token,		//在url传入token
				data:{
					"itemId":g_itemVO.id,
					"amount":1,
					"promoId":g_itemVO.promoId
				},
```

在订单方法OrderControler/createOrder下获取页面传进来的参数token，并作为是否登陆的判断标准。

```java
        String token = httpServletRequest.getParameterMap().get("token")[0];
        if(StringUtils.isEmpty(token)) {
            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,"用户还未登陆，不能下单");
        }
```



## redis缓存商品

在查询商品信息时，我们可以先去redis里查询：如果没有再从数据库里查询，并将(item_id，商品完整信息对象)存进redis里。

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd03a3b9ffa41d3ad16415bac1bf542~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

**实现代码**

在获取商品方法getItem中使用redis：

```java
//ItemController

    @Autowired
    private RedisTemplate redisTemplate;

    @RequestMapping(value = "/get",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType getItem(@RequestParam(name = "id")Integer id){

        ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get("item_"+id);
        if(itemModel == null) {
            itemModel = itemService.getItemById(id);
            redisTemplate.opsForValue().set("item_"+id, itemModel);
            redisTemplate.expire("item_"+id, 10, TimeUnit.MINUTES);
        }

        ItemVO itemVO = convertVOFromModel(itemModel);

        return CommonReturnType.create(itemVO);

    }
```

输入地址http://localhost:8090/item/get?id=6查看商品信息，在redis里即可看到存储的内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc20e3664c34940b7799195c8c16021~tplv-k3u1fbpfcp-zoom-1.image)

我们可以自定义键和值的存储方式，使其看上去能了解存储的信息。

首先我们要定义ItemModel里的属性startTime序列化格式：

```java
package com.imooc.miaoshaproject.serializer;

import java.io.IOException;

public class JodaDateTimeJsonSerializer extends JsonSerializer<DateTime> {
    @Override
    public void serialize(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeString(dateTime.toString("yyyy-MM-dd HH:mm:ss"));
    }
}

```

反序列化格式：

```java
public class JodaDateTimeJsonDeserrializer extends JsonDeserializer<DateTime> {
    //将dataString按照格式转成DateTime
    @Override
    public DateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        String dateString = jsonParser.readValueAs(String.class);
        DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");

        return DateTime.parse(dateString,formatter);
    }

}
```

自定义RedisTemplate配置类，将自定义的序列化方式注册进去。

```java
@Component
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
public class RedisConfig {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //key的序列化：String的序列化方式
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        redisTemplate.setKeySerializer(stringRedisSerializer);

        //value的序列化：Json的序列化方式
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

        ObjectMapper objectMapper = new ObjectMapper();
        SimpleModule simpleModule = new SimpleModule();
        simpleModule.addSerializer(DateTime.class, new JodaDateTimeJsonSerializer());
        simpleModule.addDeserializer(DateTime.class, new JodaDateTimeJsonDeserrializer());
        //除final外的的属性信息都需要被序列化和反序列化。
        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        objectMapper.registerModule(simpleModule);      //注册自定义的序列化和反序列模块

        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);

        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);


        return redisTemplate;
    }
}

```

结果如下图所示：

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5af882251e4d1e8c967b4ce70881e3~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:200%;" />

> redis命令 flushall 可以清除全部key-value

### Guava缓存

此外我们还可以使用com.google.common.cache作为一道新的商品缓存，Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。因此对于一些情况可以考虑使用Guava Cache：

1. 愿意消耗一些内存空间来提升速度。
2. 预料到某些键会被多次查询。
3. 缓存中存放的数据总量不会超出内存容量。

我们可以将程序频繁用到的少量数据存储到Guava Cache中，以改善程序性能。

**程序代码**

首先引入依赖：

```xml
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>18.0</version>
    </dependency>
```

定义一个封装缓存操作的接口：

```java
package com.imooc.miaoshaproject.service;

//封装本地缓存操作类
public interface CacheService {

    void setCommonCache(String key, Object value);

    Object getCommonCache(String key);
}
```

实现类：

```java
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

@Service
public class CacheServiceImpl implements CacheService {

    private Cache<String, Object> commonCache = null;
    //spring bean 会在bean加载时优先执行该注解方法
    @PostConstruct
    public void init() {
        //缓存容器的初始容量为10，缓存最多存储100个key，若超过则按照lru策略移除缓存项
        //expireAfterWrite的过期时间是相对于被写进的时间,expireAfterAccess的过期时间是相对于被访问的时间
        commonCache = CacheBuilder.newBuilder().initialCapacity(10)
                .maximumSize(100).expireAfterWrite(60, TimeUnit.SECONDS).build();
    }

    @Override
    public void setCommonCache(String key, Object value) {  commonCache.put(key, value); }

    @Override
    public Object getCommonCache(String key) {  return commonCache.getIfPresent(key); }
}
```

在商品获取的方法中通过缓存操作类来实现本地缓存：

```java
//ItemController

	@Autowired
    private CacheService cacheService;
    
    @RequestMapping(value = "/get",method = {RequestMethod.GET})
    @ResponseBody
    public CommonReturnType getItem(@RequestParam(name = "id")Integer id){
        ItemModel itemModel = null;
        //查看本地缓存
        itemModel = (ItemModel)cacheService.getCommonCache("item_"+id);

        if(itemModel == null) {
            itemModel = (ItemModel) redisTemplate.opsForValue().get("item_"+id);    //查看redis
            if(itemModel == null) {
                itemModel = itemService.getItemById(id);
                redisTemplate.opsForValue().set("item_" + id, itemModel);
                redisTemplate.expire("item_" + id, 10, TimeUnit.MINUTES);

            }
            cacheService.setCommonCache("item_" + id, itemModel);
        }

        ItemVO itemVO = convertVOFromModel(itemModel);

        return CommonReturnType.create(itemVO);

    }
```







# 初识Nginx

## 安装

**OpenResty是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。**

在[OpenResty官网](https://openresty.org/cn/download.html)下载对应.tar.gz文件后，使用命令：

```
tar -zxvf
```

解压后，根据[安装教程](https://openresty.org/cn/installation.html)进入OpenResty，执行如下命令安装开发库

```
apt-get install libpcre3-dev \
libssl-dev perl make build-essential curl
```

然后接连输入如下命令以配置，编译，安装。

```
apt-get update
apt-get install libpcre3-dev
apt-get install openssl
apt-get install zlib1g-dev
./configure
make
make install
```

它会自动安装在/usr/local/openresty下。

进入/usr/local/openresty/nginx，输入命令开启nginx。

```
sbin/nginx -c conf/nginx.conf
```

如果之前已经开启了nginx，则重启nginx即可

```
sbin/nginx -s reload
```



他会默认启动在80端口。在浏览器里输入服务器IP地址即可看见nginx的欢迎页面。

> 关于nginx的一些配置，你可以在/usr/local/openresty/nginx/conf/nginx.conf下找到。



## 反向代理

**什么是正向代理**

正向代理是一个位于客户端和目标服务器之间的代理服务器。为了从原始服务器取得内容，客户端向代理服务器发送一个请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。

正向代理需要主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去获取访问内容并返回。服务端不知道真实的客户端是谁，请求的服务都被代理服务器代替来请求。

**什么是反向代理**

反向代理隐藏了真实的服务端：代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。两者的区别在于代理的对象不同：一个是客户端，一个是服务端。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c9b5e4bd43e42929d9fb4d4573a1c9e~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />

nginx支持配置反向代理，通过反向代理实现网站的负载均衡。

**使用**

按照下图中的扩展，假设nginx部署在maioshaserver服务器下。当H5请求是一个static页面时（即静态资源请求），我们访问resources路径下的页面；当H5请求是ajax请求时，则会认定为动态请求被nginx反向代理。如下所示：

- miaoshaserver/resources/getotp.html    
- miaoshaserver/item/get?id=3

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dabf4cf1925242baba60df438fcb99cf~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:67%;" />



**配置动静分离服务器**

我们将访问的所有页面放在resources文件夹下，并将resources文件夹放在nginx的html文件夹里。

执行`vim /usr/local/openresty/nginx/conf/nginx.conf`进入文本编辑器，然后按i进入编辑模式，并按下图修改页面定向：

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62f23a8446464c44a2b2d7ca4bb379ff~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

```
 #gzip  on;
 	#(1)
    upstream backend_server{					
        server 120.25.205.138  weight=1;		
        #server 第二个放置jar包的应用服务器的内网ip地址  weight=1;		
        										
    }


    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;
		#(2)
		
        location /resources/  {
        	add_header Access-Control-Allow-Origin *;  #跨域问题
            alias /usr/local/openresty/nginx/html/resources/;
            index  index.html index.htm;
        }
        
		
		#(3)
       location / {
         add_header Access-Control-Allow-Origin *;	#跨域问题
         add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';

         add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

         if ($request_method = 'OPTIONS') {
                return 204;
          }
     
         proxy_pass http://backend_server;					
         proxy_set_header Host $http_host:$proxy_port;		
         proxy_set_header X-Real-IP $remote_addr;	#
         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       }
```

下面解释以下上述三点的设置概念：

（1）后端服务器集群backend_server。这里面是部署jar的各个服务器ip地址，此处本应是私网地址，这样速度会快点。但我这里是公网地址

weight表示权重，如果两个权重为1，则表示有一半的请求轮询到其中一个。

（2）当localtion的规则命中了/resources/目录后，alias字段将/resources/替换为/usr/local/openresty/nginx/html/resources/。

（3）除了对resources下的请求，我们都当作动态资源请求。	

- proxy_pass http：nginx将请求反向代理到http://backend_server上
- Host $http_host:$proxy_port：拼接上对应的域名和端口
- 设置后端服务器拿到的真正ip地址X-Real-IP是远端客户端地址，若不设置则它拿到的是nginx地址
- proxy_add_x_forwarded_for变量包含客户端请求头中的"X-Forwarded-For"。一般情况下，当用户请求经过内容分发网络CDN到达nginx时，下X-Forwarded-For头信息为客户端IP，则此处我们又设置了一次，X-Forwarded-For的内容就变成 ”客户端IP,Nginx负载均衡服务器IP“；但如果从CDN过来的请求没有设置X-Forwarded-For头（通常不会发生），而在这里我们又设置了 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  那么X-Forwarded-For的信息是CDN的IP，此时后端程序无法获取用户IP地址。

按Esc然后`:wq`退出编后，执行 `sbin/nginx -s reload `重启nginx。

总结来说：当我们向nginx服务器miaoshaserver发起请求时，比如说miaoshaserver/resources/getotp.html ，它将会返回放置html/resources下的对应页面。我们在页面填写完信息后，getotp将向miaoshaserver发起ajax请求，nginx服务器会将这个ajax请求代理到两个应用服务器（私网ip）中的一个。



**查看日志**

我们可以在项目的配置文件里开启tomcat access log来验证反向代理是否成功。

进入项目文件夹miaosha下的外挂配置文件application.properties，添加：

```
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.directory=/usr/local/java_project/miaosha/tomcat
server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b %D

#   %h表示远端host地址（远端IP地址）
#   %l 默认返回-
#   %u 表示远端主机user
#   %t 表示处理时间
#   %r 打印请求的方法/url
#   %s HTTP返回状态码
#   %b 表示请求response的大小
#   %D 表示处理请求时长
```

在miaosha下新建文件夹tomcat，授权所有权限`sudo chmod 777 tomcat/`，这个文件夹放置nginx代理请求的日志文件地址。

在地址栏发起请求：miaoshaserver/item/get?id=3，会发现tomcat文件夹多出一个以时间命名的日志文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3ead9baf46431c94c1b9253c4fddf9~tplv-k3u1fbpfcp-zoom-1.image)





## 内存字典

shared dic是基于nginx内存一个缓存，它对所有worker进程可见。它类似于Gruva cache的key-value的数据结构，同时它可以指定最近最少未使用lru的淘汰规则。因此我们同样可以把商品信息存进nginx里。当有对商品的查询请求进入nginx时，nginx首先查询字典里是否有对应的数据，若有则返回，否则向应用服务器发起请求。

**操作步骤**

首先在`openresty/conf/nginx.conf`下定义字典和请求的规则：

```
#指定内存字典的大小
lua_shared_dict my_cache 128m;

    server {
       #省略...
        
        #将luaitem/get请求代理到指定的Lua脚本
        location /luaitem/get {
        
            default_type "application/json";
            content_by_lua_file ../lua/itemsharedic.lua;
        }
```

在`openresty下创建存放lua脚本的文件夹lua`，然后在文件夹里创建一个itemsharedic.lua的脚本：

```lua
function get_from_cache(key)
         local cache_ngx = ngx.shared.my_cache
         local value = cache_ngx:get(key)
         return value
end      

function set_to_cache(key,value,exptime)
        if not exptime then
                exptime = 0
        end     
        local cache_ngx = ngx.shared.my_cache
        local succ,err,forcible = cache_ngx:set(key,value,exptime)
        return succ
end     

local args = ngx.req.get_uri_args()
local id = args["id"]
local item_model = get_from_cache("item_"..id)
if item_model == nil then
        local resp = ngx.location.capture("/item/get?id="..id)
        item_model = resp.body
        set_to_cache("item_"..id,item_model,1*60)
end     
ngx.say(item_model)


```

解释一下这个脚本：从请求的uri（ngx.req.get_uri）中取出参数args，并提取出id字段。尝试着根据id从之前定义的内存字典my_cache取出对应的itemModel：

- 若不存在，则发起 /item/get?id 请求，并从响应中取出itemModel，放入内存字典里。
- 然后ngx.say(itemModel)



## redis操作

同样我们可以在nginx里操作redis，在`openresty/lualib/resty`里，存储了操作redis的lua脚本redis.lua。因此我们可以如操作内存字典一样去操作redis。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd4be18e02e842c49b2d2b43d379587f~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;" />

**操作步骤**

在`openresty/lua`创建itemredis.lua

```
local args = ngx.req.get_uri_args()
local id = args["id"]
local redis = require "resty.redis"
local cache = redis:new()
local ok, err = cache:connect("172.18.190.68", 6379)
local item_model = cache:get("item_"..id)

if item_model == ngx.null or item_model == nil then
        local resp = ngx.location.capture("/item/get?id="..id)
        item_model = resp.body
end

ngx.say(item_model)
```

在将前面的`openresty/conf/nginx.conf`下修改指定的lua脚本为itemredis.lua

```
content_by_lua_file ../lua/itemsharedic.lua
```



# Rocketmq

## 入门

~~参考[官方文档](https://rocketmq.apache.org/docs/quick-start/)。~~

> ps：官网文档贼坑人，害我找错误找到贼久。参考如下博客
>
> [No route info of this topic以及org.apache.rocketmq.remoting.exception.RemotingTooMuch异常](https://blog.csdn.net/qq_35580701/article/details/107055506)



（1）在解压完rocketmq后，进入文件，首先修改一下大小：

```
vim bin/mqbroker.xml
```

来修改mqbroker

```
-XX:NewSize>128M</-XX:NewSize>
<-XX:MaxNewSize>128M</-XX:MaxNewSize>
<-XX:PermSize>64M</-XX:PermSize>
<-XX:MaxPermSize>64M</-XX:MaxPermSize>
```

执行

```
vim bin/runbroker.sh
```

修改java的启动配置：

```
JAVA_OPT="${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn512m"
```

（2）开启namesrv和mqbroker：

```
nohup sh bin/mqnamesrv -n 120.25.205.138:9876 &

nohup sh bin/mqbroker -n 120.25.205.138:9876 -c conf/broker.conf autoCreateTopicEnable=true &
```

你可以通过如下命令查看namesrv和mqbroker的日志

```
tail -f ~/logs/rocketmqlogs/namesrv.log
tail -f ~/logs/rocketmqlogs/broker.log
```

（3）指定环境变量：` export NAMESRV_ADDR=localhost:9876`。

**生产和消费示例**

投放服务：`sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer`

消费服务：`sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer`

目前我们使用的topic是rocketmq自带的TopicTest，我们也可以自定义topic。

进入bin文件，执行如下命令创建一个名为stock的topic：

```
./mqadmin updateTopic -n localhost:9876 -t stock -c DefaultCluster
```

**在程序中使用**

在主配置文件中配置：

```
mq.nameserver.addr=120.25.205.138:9876	#放置RocketMQ服务器公网ip
mq.topicname=stock
```

导入依赖：

```xml
  <dependency>
        <groupId>org.apache.rocketmq</groupId>
        <artifactId>rocketmq-client</artifactId>
        <version>4.3.0</version>
    </dependency>
```
