## 移动零

[leetcode283](https://leetcode-cn.com/problems/move-zeroes/)

**题目**：

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。



**题解**：

（1）两次遍历

定义一个变量j，用来表示移动零后非零数的下标。遍历数组时每遇到一个非零数，则将其移到j处。第二次遍历时[j，len - 1]全为零。

```java
    public void moveZeroes(int[] nums) {
       int i, j = 0, len = nums.length;
       if(len == 0)  return;
       for(i = 0; i < len; i++) {
           if(nums[i] != 0) {
               nums[j++] = nums[i];
           }
       }
       for(i = j; i < len; i++) {
           nums[i] = 0;
       }
    } 
```

（2）快排思想

快排思想是指将小于某一数x放在x左边，大于x的放在x右边。

本题我们可以将0作为数字x，遇到小于0的数就放在0左边。

![](https://user-gold-cdn.xitu.io/2020/7/8/1732d25506c5be5c?w=676&h=758&f=jpeg&s=86284)

```java
    public void moveZeroes(int[] nums) {
        //j表示为数字0的下标，j的左边都是非零数
       int i = 0, j = 0;
       for(; i < nums.length; i++) {
           if(nums[i] != 0) {
               int tmp = nums[i];
               nums[i] = nums[j];
               nums[j++] = tmp;
           }
       }
    } 
```



## 相交链表

[leetcode160](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**题目：**编写一个程序，找到两个单链表相交的起始节点。

**示例1**：

![](https://user-gold-cdn.xitu.io/2020/7/8/1732dba889d2ae03?w=441&h=150&f=png&s=13229)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```



**题解**

假设两个链表长度分别为L1+C、L2+C， 其中C为公共部分的长度。设置两个指针a和b 分别从A B两个链表头开始走：

- 如果两链表有相交部分：若L1 == L2，则当a走了L1，b指针走了L2后，即可相遇于第一个公共节点；而如果L1 != L2，则当a走了L1+C后，回到B起点走L2步，b指针走了L2+C后，回到A起点走L1步。这样两个指针都走了L1+L2+C，肯定会相遇于第一个公共节点。
- 若两链表没有相交部分：当a走了L1+C后，回到B起点走L2步后变为空；b指针走了L2+C后，回到A起点走L1步后变为空。

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA, curB = headB;
        while(curA != curB) {
            curA = curA == null ? headB : curA.next;
            curB = curB == null ? headA : curB.next;
        }
        return curB;
    }
```



## 删除排序数组中的重复项

[leetcode26](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

**题目**：

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成

**示例 1**:

```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2**:

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```



**题解**

定义快慢指针i，j。只要nums[i] = nums[j]，我们就增加 i 来跳过重复项。当遇到nums[i] ≠ nums[j]，则nums[++j] = nums[i]。

![](https://user-gold-cdn.xitu.io/2020/7/8/1732ecd30fb1782d?w=1080&h=435&f=jpeg&s=92418)



```java
    public int removeDuplicates(int[] nums) {
        int i, j = 0;
        for(i = 1; i < nums.length; i++) {
            if(nums[i] != nums[j]) {
                j++;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }
```



## 颜色分类

[leetcode75](https://leetcode-cn.com/problems/sort-colors/)

**题目：**给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**
不能使用代码库中的排序函数来解决这道题。

**示例:**

```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**进阶：**

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？



**题解：**我们用两个变量low1，low2分别表示[0, low1]都是小于1的数，[0, low2]都是小于2的数

```java
class Solution {
   
    public void sortColors(int[] nums) {
        //[0, low1]都是小于1的数，
        int low1 = -1, low2 = -1;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] < 2) {
                swap(nums, ++ low2, i);
                if(nums[low2] < 1) {
                    swap(nums, ++low1, low2);
                }
            }
        }
    }

    private void swap(int[]nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 三数之和

[leetcode15](https://leetcode-cn.com/problems/3sum/)

**题目：**给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。



**示例：**

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

```
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```



**题解：**将数组升序排列，遍历数组：

- 如果nums[i] == nums[i-1]，由于nums[i-1]构成的三元组已经找到（或者可以确定不存在）了，因此跳过这个i
- 将-nums[i]的负数作为目标值，left指针指向i + 1，right指针指向len - 1，不断循环直至left等于right
  - 如果nums[left] + nums[right] 等于目标值：放入结果队列后，将left++，right--继续搜寻，但是要注意可能会出现的重复值。 比如说[-2, -1, -1, -1, 3, 3, 3]， i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3。
  - 如果大于目标值，则right--以便缩小两者的总和
  - 否则left++以便增大两者的总和



```java
	public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        for(int i=0; i<len; i++) {
            if(nums[i] > 0) {   //i后面的数肯定大于0，因此退出循环
                break;
            }
            if(i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int curTarget = -nums[i];
            int left = i+1, right = len-1;
            while(left < right) {
                if(nums[left] + nums[right] == curTarget) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    left++;     right--;
                    while(left < right && nums[left] == nums[left - 1]) {
                        left++;
                    }
                    while(left < right && nums[right] == nums[right + 1]) {
                        right--;
                    }
                }else if(nums[left] + nums[right] < curTarget) {
                    left++;
                }else {
                    right--;
                }
            }
        }
        return ans;
    }
```



## 和为s的连续正数序列

[剑指offer57](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

**题目：**输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 

**示例 1：**

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```


**示例 2：**

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

**限制：**

1 <= target <= 10^5



**题解：**滑动窗口思想

用两个指针left = 1，right = 1表示区间[left, right)，sum表示区间的和。

比较区间和sum和target的大小：

- 若sum < target，则说明以left为起始点的区间和较大，将left++；

- 若sum > target，则说明以right-1为结尾点的区间和较小，将right作为区间的一部分，并right++。
- 若sum = target，则说明该区间是我们要的答案。放入答案列表里后，将left++作为新的起始点。

需要left的取值范围应是[0, target / 2]，举例说明：数字9的一个答案区间是[4, 5]，如果left为target/2+1，则以left为起始点的区间不可能是答案。

```java
 public int[][] findContinuousSequence(int target) {
        List<int[]> ans = new ArrayList<>();
        int left=1, right=1, sum=0;
     
        while(left <= target/2) {
            if(sum < target) {
                sum += right;
                right++;
            }else if(sum > target) {
                sum -= left;
                left++;
            }else {
                int[] tmp = new int[right-left];
                for(int i=left; i<right; i++) {
                    tmp[i-left] = i;
                }
                ans.add(tmp);
                sum -= left;
                left++;
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
```

**复杂度：**

- 时间复杂度：O(target)
- 空间复杂度：O(1)