# 布隆过滤器

## 什么是布隆过滤器

布隆过滤器是一个由很长的二进制向量（位数组）和一系列随机映射函数（哈希函数）组成的数据结构，它可以用于检索一个元素是否在一个集合中。 

### 原理

布隆过滤器 本质上 是由长度为 `m` 的位向量或位列表（仅包含 `0` 或 `1` 位值的列表）组成，最初所有的值均设置为 0

![](https://user-gold-cdn.xitu.io/2020/7/11/1733d6961fa51ef7?w=605&h=100&f=png&s=8118)

当我们向们向布隆过滤器中添加数据时，会使用 多个 `hash` 函数对 `key` 进行运算，在得到每个hash函数算出不同位置后，将位数组里对应的位置都置为1就完成了`add`操作。

当我们向布隆过滤器查查询 `key` 是否存在时，跟 `add` 操作一样，会把这个 `key` 通过相同的多个 `hash` 函数进行运算，查看 对应的位置 是否 都 为 `1`，只要有一个值为 0，那么说明布隆过滤器中这个 `key` 不存在。如果这几个位置都是 1，并不能说明这个 key一定存在，只能说极有可能存在，因为这些位置的 1可能是因为其他的 key存在导致的。
**优点：**数据空间小，不用存储数据本身

**缺点：**

- 元素可以添加到集合里，但不能被删除
- 它只能保证匹配结果肯定不在集合里，但不能保证匹配成功的值一定在集合里。并且当集合快慢时，误报的概率会变大。

布隆过滤器的应用场景有：

- 在一个大数据量中判断某数据是否存在
- 解决缓存穿透

## Guava

 Google 开源的 Guava 中有自带的布隆过滤器。对应的Maven依赖如下:

```xml
<dependency> 
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId> 
    <version>28.0-jre</version> 
</dependency>
```

然后我们就可以在java中使用了：

```java
    BloomFilter<Integer> filter = BloomFilter.create( Funnels.integerFunnel(), 1500, 0.01); 
    //添加元素
	filter.put(1);
	//判断元素是否存在
	System.out.println(filter.mightContain(1));
```

不过Guava 提供的布隆过滤器只能是单机使用 ，考虑到如今的互联都是分布式，因此我们需要使用Redis的布隆过滤器。



# 持久化

Redis的数据全部存储 在内存 中，如果 突然宕机，数据就会全部丢失，因此必须有一套机制来保证 Redis 的数据不会因为故障而丢失，这种机制就是 Redis 的 持久化机制，它会将内存中的数据库状态 保存到磁盘 中。

**如何保证持久化安全**

首先我们先讲述一下从客户端开始发起`写请求`到服务器将数据写入磁盘的过程：

1. 客户端向数据库发送写命令，此时数据在客户端内存中
2. 数据库接收到客户端的写请求，此时数据在服务器的内存中。
3. 数据库调用系统API写入磁盘中，此时数据在操作系统的内核缓存中
4. 操作系统将 写缓冲区 传输到 磁盘控控制器，此时数据在磁盘缓存中
5. 操作系统的磁盘控制器将数据 写入实际的物理媒介中 ，此时数据在磁盘中

如果计算机故障只是软件层面上(进程被管理员终止或程序崩溃)，并且没有接触到内核，那么在上述步骤3成功返回后，我们就可以认为成功了，操作系统会帮我们把数据正确写入磁盘。但如果是停电/火灾等更严重的故障，那么只有完成第5步后才可以认为是安全的。

因此我们首先从第3步开始，Linux提供了用于操作文件的 `POSIX file API`，我们可借此完成第3步

```
int open(const char *path, int oflag, .../*,mode_t mode */); 
int close (int filedes);int remove( const char *fname ); 
ssize_t write(int fildes, const void *buf, size_t nbyte); 
ssize_t read(int fildes, void *buf, size_t nbyte);
```

对于第4步：实际的计算机硬件都是通过OS的系统调用来操作的，Linux默认在30秒后实际提交磁盘缓存里的数据，如果在此期间出现故障，那么最近30秒写入的数据都会丢失。因此我们可以使用`PROSIX API`提供的`fsync`命令，它可以强制内核将 缓冲区 写入 磁盘，但这是一个非常消耗性能的操作，每次调用都会 阻塞等待 直到设备报告 IO 完成，所以一般在生产环境的服务器中，**Redis** 通常是每隔 1s 左右执行一次 `fsync` 操作。

至于第5步我们是无法控制的。

## Redis的两种持久化方式

### 快照

当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在 2 分钟前创建的，并且现在已经至少有 `100` 次新写入，则将创建一个新的快照。此条件可以由用户配置 Redis 实例来控制，也可以在运行时修改而无需重新启动服务器。快照作为包含整个数据集的单个 `.rdb` 文件生成。

**fork函数和Copy On Write机制**

Redis是一个单线程程序，这意味着它不仅要响应用户请求，还需要进行内存快照。而后者要求 Redis 必须进行 IO 操作，这会严重拖累服务器的性能。还有一个可能出现的问题：我们在 持久化的同时，内存数据结构 还可能在 变化，比如一个大型的 hash 字典正在持久化，结果一个请求过来把它删除了，可是这才刚持久化结束，该怎么办？

Redis持久化时会调用 `glibc` 的函数 `fork` 产生一个子进程

![](https://user-gold-cdn.xitu.io/2020/7/11/1733e1160e306fe8?w=743&h=296&f=png&s=50616)

快照持久化交给子进程，父进程则继续处理客户端请求。此时的父进程可能对内存数据结构进行不间断的修改，因此这时就会使用操作系统的**Copy On Write机制**来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后 对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，页面的数据还是子进程产生时那一瞬间的数据，并且再也不改变。



### AOF

快照并不持久，因此我们有**仅追加文件AOF**来代替。它的工作方式是：每次执行修改内存中数据集的写操作时，先执行指令，然后将指令文本存储到日志里。我们可以对一个空的Redis顺序执行AOF记录的指令，依次恢复Redis的内存数据结构状态。

**AOF重写**
Redis在长期运行的过程中，AOF日志会越来越长，这样的重放过程会非常耗时。因此我们需要对AOF瘦身。

Redis提供了 `bgrewriteaof` 指令用于对 AOF 日志进行瘦身，其原理是开辟一个子进程 对内存进行 遍历 转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件 中。序列化完毕后再将操作期间发生的 增量 AOF 日志 追加到这个新的 AOF 日志文件中，追加完毕后就立即替代旧的 AOF 日志文件了，瘦身工作就完成了。

**fsync**
与之前`如何保证持久化安全`一小节的第4步一样，我们可以借助glibc 提供的 `fsync(int fd)` 函数来将指定的文件内容 强制从内核缓存刷到磁盘。Redis提供了两者策略：（1）永不fsync，由操作系统定何时同步磁盘；（2）执行一个指令就fsync一次。

**AOF对过期键的处理**

（1）如果数据库某个过期键还没被删除，那么AOF文件依旧保留。一旦过期键被删除后，程序会向 AOF 文件追加一条 DEL 命令来显式地记录该键被删除。

（2）执行 AOF 重写过程中，也会被数据库的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中



#### **混合持久化RDB**

AOF日志性能相对于快照而言性能要慢很多，如果Redis实例很多，重启Redis会花费很长时间。Redis 4.0 为了解决这个问题，带来了一个新的持久化选项：**混合持久化**。它将 `rdb` 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 **自持久化开始到持久化结束** 的这段时间发生的增量 AOF 日志。当Redis重启时，先加载rdb的内容，再重放增量AOF日志





# 参考资料

[Redis中bigkey是什么，如何优雅的处理big key](https://www.liangseo.com/article/15)

[我没有三颗心脏：布隆过滤器](https://www.wmyskxz.com/2020/03/11/redis-5-yi-ji-shu-ju-guo-lu-he-bu-long-guo-lu-qi/)

[我没有三颗心脏：持久化](https://www.wmyskxz.com/2020/03/13/redis-7-chi-jiu-hua-yi-wen-liao-jie/)

[掘金老錢：布隆过滤器](https://juejin.im/post/5c9442ae5188252d77392241)